2010-10-06:
Began with the project. Studied the documents, the simulator and so on.

2010-10-11:
Created the code-structure, svn-repo and so on.
Design-decisions:
 - we'll use C99 because I think its better suited for new projects. Since its the current
   standard, it exists more than 10 years, nearly every compiler supports it and it provides
   some useful new features (uintX_t-types, boolean-datatype, inline-functions, local-variable-
   declaration at arbitrary locations (including for-loop), ...)
 - we'll typedef octa as uint64_t. This way we can benefit from 64-bit platforms (but support
   32-bit platforms as well). The code will be MUCH shorter, easier and cleaner. But probably
   we will do multiplication and division by hand, like Knuth did. Of course, the disadvantage is,
   that some things are different (no code copy-pasting). But I think, its doable.
Implemented physical- and virtual-memory. Virtmem is very primitive, but thats enough for now :)
Physmem uses the treap, that Knuth has used, too, to be able to provide a lot of main-memory, but
only pay for it if we really use it.
And we have a simple loader that reads a MMX-file (generated by the gimmo2mmx-tool from Mr. geisse)
and simply puts the stuff at the corresponding location in memory. No virt->phys translation yet,
therefore its simply put at the specified physical locations!

2010-10-13:
Established test-infastructure (ok, probably not final). Used the test-stuff from escape and changed
it a bit. I took a look at existing unittest-frameworks for C (e.g. CUnit or Check), but most of
them are too big and would clutter the project-directory too much. Additionally we won't need most
of it. So I think, its better to create our own, simple and small test-framework.

2010-10-14:
Build the first instructions and build a disassembler

2010-10-15:
Build ROM-test-infrastructure. That means my sim and the mmix has a --postcmds command-line-argument
with which we can specify what stuff should be printed after execution of the program. This way
we can write that to a file and use diff to show possible differences.

2010-10-16:
Worked on integer-arithmetic. And I decided to use the exception-strategie from mr. geisse. I think,
it makes sense to do it that way because it gives e.g. devices the chance to simply fire an interrupt
and the caller doesn't need to check for it. So its a very clear and simple way. Atm we don't use
the feature of having nested exceptions. But it doesn't hurt, so I keep it for now :)
But we need a better exception-strategie for arithmetic-exceptions. Because we have for example
bus-errors when accessing memory-mapped devices and we have many arithmetic exceptions that should
not always fire an exception but only if the corresponding bit in rA is set. The question is if we
should mix that stuff or if we should introduce just one arithmetic-exception and pass the bit
for rA separatly or something else...

2010-10-17:
Implemented cmp, neg, load and store-instructions.

2010-10-18:
Implemented most of the exotic bit-fiddling-instructions

2010-10-26:
Worked on the CLI-language the last days. The goals were:
1. Provide a simple, intuitive, convenient and flexible interface to MMIX
2. It should be possible to add commands very easily (which implies that developing a cmd should be
   simple)
3. It should be performant, for example to be able to use it for scripting. E.g. the user should
   be able to output the memory from 0 to 50MiB, write that to a file and analyze it afterwards.
It wasn't easy to achieve these goals. My idea was to develop a small language which supports
several arithmetical stuff and especially specific expressions for MMIX. So for example for getting
the content of a register, of memory and so on. Additionally I wanted to have "ranges". That means,
I wanted to be able to say something like "d @:12" do disassemble 3 instructions at the PC. So,
ranges should be integrated into the language, so that they're short and usable everywhere.
Because of the third goal it wasn't possible to simply convert that ranges to an array of integers
and pass that to commands. This way would perhaps be more simple for commands, but could cost a lot
of memory and time. Therefore I had the idea to simply give the eval-function an offset and let
the function tell the caller if its finished. So, based on the offset it chooses the correct value
in the range.
That worked, but there were many other things to solve. I tried a lot and thought a lot about this
stuff and I think, finally I've found a got solution for all problems.
For example, I wasn't sure whether I should integrate special commands hardcoded into the language.
That could have made sense for print and set. Because they (perhaps other as well) need definitely
a possibility to get the type of thing they got. E.g. print should know that it should print
something from memory and from where. Otherwise it isn't able to print this information. The set-
command needs to know that as well to know where to write to.
Finally I decided not to build these commands into the language but make them ordinary commands. This
works because everybody knows the "origin" of a value. As soon as no arithmetic and so on is involved
(so its a "pure" memory access for example), the origin is known. Otherwise its simply an arbitrary
expression. This information, including the "location" (memory-address, register-number, ...), is
attached to the command-arguments.
Another problem was the number of bytes that M or m should access. At first, there were just M and m
that fetched always 8 byte (without align-check). The commands had to take care that they extracted
the right thing and were also responsible for incrementing the offset depending on the amount of
bytes to read or similar. Well, that was a bit confusing, I would say :)
Finally I've added M1,M2,M4,M8 and the same for m, so that the user can specify how many bytes to
fetch and what alignment it has to have. Previously that was passed as an argument to print or set.
Thats much easier IMO.
I decided to disallow the usage of nested ranges. So for example "(1..2)..3". Of course one could
give them a meaning, but I think there is no real use for them and its difficult for humans to see
what it means. Therefore I think its better to disallow that.

2010-10-27:
Thought about the implementation of interruptable instructions like pushj or the nearly always
present reg_set. After speaking to Mr. Geisse, reading the spec and thinking a lot about it, we've
decided to make it simple: all instructions are atomic, i.e. not interruptable.
This is a correct implementation of MMIX, according to the spec:
	Non-catastrophic interrupts in MMIX are always precise, in the sense that all legal instructions
	before a certain point have effectively been executed, and no instructions after that point have
	yet been executed. The current instruction, which may or may not have been completed at the time
	of interrupt and which may or may not need to be resumed after the interrupt has been serviced,
	is put into the special execution register rX, and its operands (if any) are placed in specia
	lregisters rY and rZ.
Another possible implementation I thought about, would have been to separate an instruction in 3
phases:
1. load: load the operands (load the value of an register, ...)
2. execute: execute the operation (make an addition, ...)
3. commit: commit the changes to the machine (write in register, to memory, ...)
Each phase could be separated in multiple cycles and the instruction could decide when its finished.
To achieve this, we could pass an instruction-struct with all required information (instruction
itself, loaded operations, result, ...). This way we have a clean separation of the different
things that happen and could interrupt after (nearly) any cycle. We would store the state of an
instruction in rX, rY and rZ, like MMIX specifies and resume it correspondingly.
But of course, this concept makes the whole thing more difficult and makes it not that easy to see
what a specific instruction does. On the other hand it would probably be more realistic, in the
sense that it would be more like a later hardware-implementation.
However, we've decided to go the simple way, because:
- the goal is to build an operating system for that simulator, and test&debug it with it
- that means, the most important thing is correctness
- therefore, we've decided to do it simple. The OS would have to be spec-conform anyway

2010-10-30:
Decided to split the instructions into 2 parts: decode and execute
The decode-phase extracts the stuff from the 4-byte instruction and puts it in an argument-format,
that each instruction specifies. So each instruction has a instruction-format and argument-format.
The union sInstr contains structs for the different argument-formats.
The reason for this concept is that we need to be able to change the operands with the resume-
instruction. So for example add might rise a arithmetic-exception, that changes the operands,
and tries to execute add again. Therefore, I think, the best solution is to separate the decoding
from the execution. That means that we'll read the operands from registers in the decode-phase,
if necessary.
Theoretically it would be possible to do that only for these instructions for which we allow to
change the operands (the "spec" says its possible, when it makes sense ;D). But I think its cleaner
to do it for all. The advantage is also that the instruction-execution gets simpler. For example
we have no separate functions for forward- and backward-branches and so on.
The disadvantage is of course, that its no longer possible to see a whole instruction at one place.

2010-11-29:
After a long think-try-debug-and-read-session, I've finally found out how we can execute 
instructions at privileged addresses in the pipeline-simulator. Well, in the end its really
simple :D
When we're using the hexadecimal input-format, by default everything is uninitialized (special-
registers and so on). Even the instruction-pointer is not initialized (the pipeline-simulator
is intended for interactive execution only). That does include rK, i.e. the interrupt mask register
is zero, so that all interrupts are disabled. This is important because if the P-bit is enabled
and we're at negative addresses, an exception is raised.
We can initialize some important things via unsave. So we prepare a certain memory-region (we can
write data to arbitrary physical addresses by using the hexadecimal input-format) corresponding to
the unsave instruction and then execute unsave. This way we can initialize global registers, rL, rG,
rA and several other special registers.
To be able to use the pipeline-simulator for non-interactive testing, we set the instruction-pointer
to #8000000000001000.
Another important thing is that paging is not pre-configured in the "unmanaged" environment (in
contrast to the "user-environment" in which programs loaded in the binary format execute). That
means, if we want to access non-negative addresses we have to set up rV, page-table-pointers and
page-table-entries. To avoid that we can simply use negative addresses :)
Another small modification to the pipeline-simulator was necessary: We need a way to terminate. By
default this is not possible (without human interaction). Therefore I added a 'return' from the
MMIX_run() function when we want to execute a trap with X=Y=Z=0. I'm not sure if we can keep that
forever because the spec says "If XYZ = 0 in a TRAP command, a user process should terminate.". I
don't know why the hardware has to constraint that. Perhaps its just for his play-simulators...
But perhaps there is a good reason. Anyway, if there is, we would have to remove that, eventually.

2010-11-30:
I've found an interesting thing: If we do a "GET $X,rL" $X will be set to the potentially new value
of rL, not to the old one. Means, if X >= rL, $X will be X + 1.
A related special case is: If we do a "GET $X,rS", $X will be set to the potentially new value
of rS, not the old one. Means if a value is stored on stack to be able to set $X, we get the
changed value of rS.

2010-12-01:
An important thing when it should work both on 32-bit and 64-bit architectures is that we are
carefull with '~' and '-' operations. So, the binary complement and negation. Because if we do
for example something like ~sizeof(int) sizeof() may be a 32-bit quantity on 32-bit systems and a
64-bit quantity on 64-bit systems. therefore, on 32-bit we get #FFFFFFFC and on 64-bit
#FFFFFFFFFFFFFFFC. The same with the negation.
Another thing, of course, is when we use mprintf or similar. We have to keep in mind that on 64-bit
platforms an int may be 64-bit large and an octa, too. On 32-bit platforms an int may be 32-bit
large and an octa 64-bit. That means, if we pass an octa to printf and use it with %d for example,
it will work on 64-bit platforms but NOT on 32-bit platforms.

2010-12-19:
While testing the resume-instruction I discovered a strange behaviour of the pipeline-simulator.
It does not really do a SETH, SETMH and SETML (the same for INC and OR). Instead it simply does a
set. That means it takes rZZ/rZ as the value and sets it into the register that the set-instruction
specifies. But thats not the real behaviour of SETH for example. Because SETH $0,#1234 should set
$0 to #1234000000000000. So, in my opinion, if we have this instruction and do a resume-continue
with rZZ = #1234, it should also set $0 to #1234000000000000. But the pipeline-simulator would set
$0 to #0000000000001234.
The reason for that is, that if we trigger an interrupt after issuing a SETH-instruction, so that
it does a resume-again, it has already set the argument for SETH to #1234000000000000. This goes
into rZZ, so that it gets used in the correct way.
Note that resume-continue is never used when interrupting a set/or/inc-instruction. This is only
used for FREM, SYNCD and SYNCID.
My guess is that the pipeline-simulator has this behaviour for convenience in its implementation.
Because, as I said, its needed for resume-again and it works correctly with it. So, perhaps he
decided to use this also for manually constructed resume-continue's.
The specification says nothing about the exact behaviour of resume-continue. It simply says:
"... it substitutes rY and rZ for the two operands, assuming that this makes sense for the operation
considered."
So its completely unspecified which instructions are supported and in what way. For example I guess
it would also be legal to use rY instead of rZ for DS-instructions like SETH and so on.
I think, at first it makes more sense to implement the DS-instructions with resume-continue in the
same way they work when they are executed directly, and second, in my implementation its also the
easiest way to do so.

2011-01-27:
Found a strange behaviour of MMIX when using the GO-instruction and testing exceptions. At first,
GO sets $X even if the PC-chance raises an exception. Second, the PC-change is performed BEFORE
the exception is raised. That means, rWW contains the new (illegal) PC, so that the OS has to take
care that the process does not go to that location. Ok, typically the OS would kill the process
anyway.

2011-01-30:
I decided to split virtmem and tc into two modules. This way we have the tc-management including
translation separated from the read/write-functions. Additionally I decided that virtmem should
offer separate read/write-functions for the CLI which does not use the TC. That means address
translation is always done and is not stored in TC. I think thats better because otherwise reading
from virtual memory in the CLI would have an effect on the state of the machine. For example, if
an operating system has cleared the TC, executes a few instructions afterwards that don't affect
the TC and expects that the TC is untouched, we would have a problem. Because if the user debugs
this application he would have to be carefull at this point not to read values from virtual memory.
I think this is not acceptable. Additionally its conceptually much nicer to specify that the
CLI does not change the state unless it is explicitly used for that (the set command).

2011-01-30:
I noticed (again?) that we have to be VERY carefull at nearly all places in the core-modules.
Because everything has to be in a consistent state if an exception occurrs. The best-case would
of course be to change nothing as soon as we notice that something is wrong. But it seems that we
can't achieve that in all situations. Or at least, sometimes it would be very expensive (when we
think of an hardware-implementation). For example, every reg_set can lead to an exception. The only
ways to make this operation atomic would be either to save the whole state that can change and
restore it in the exception-case or do a "simulation-run" first. Both is not acceptable.
However, this example is not really a problem, because we can simply do it step by step. If an
exception occurrs we will continue where we stopped.
The function reg_save IS a problem. Because it does not allow to simply restart it on an exception
since it modifies the state in a way that can't be done twice. I decided for this case to save
rO and rS, catch an exception in the critical area and restore it in this case. Of course, the
memory would still change. But we would simply overwrite it on re-execution of that instruction.

2011-01-30:
A question arised: Lets suppose a user-app performs an unsave from a stack that is not readable.
Of course, this would lead to an exception and the dynamic-trap-handler would be called. What
should the OS do? To be able to do something usefull it has to save the registers first. The obvious
instruction to do so would be save. But the stack-pointer is invalid, so that (assuming that rK is
0), the stores would have no effect. That means, we would not save the registers.
One could think that we can avoid that by doing the saves manually to a different location. That
does not work either because the kernel has no register to use. All registers are usable by the
user-process and need therefore be saved first. And we need at least one register to build the
address to write to.
Therefore I think there is really no way out of this problem. That means, it is not possible in
the current version of MMIX to extend the user-stack on demand.
This problem is described here as well: http://www007.upp.so-net.ne.jp/eiji-y/vmmmix/problem.html
But perhaps we can change the architecture so that this is allowed. What if we would provide two
separate special-registers, rSS and rOO, that are used in kernel-mode? This way the kernel could
setup a different stack for each process that is used in kernel-mode. This way the kernel could
save the state of the process on that stack and use it in kernel-mode.

2011-01-31:
I found out that the pipeline-simulator will execute some instructions although they are invalid
(cause exception). I don't know all instructions, but an example is PUT. If I make a PUT rG,0
(which breaks the rules and causes therefore a b-exception), mmmix executes this instruction and
really sets rG to 0. Additionally it sets rQ.
The "spec" says:
	An instruction that causes a dynamic trap is usually executed before the interruption occurs.
	However, an instruction that traps with bits x, k, or b does nothing; a load instruction that
	traps with r or n loads zero; a store instruction that traps with any of rwxnkbsp
	stores nothing.
So according to the spec, the behaviour is wrong. Because the instruction traps with bit b and
changes the state of the machine.
NOTE: Even in usermode mmmix will set rG to zero (and will do a trap afterwards).

2011-02-01:
I decided to make my simulator behave differently regarding exception-handling due to bits set
in rQ and rK. There are two situations:
1. I set rK and rQ manually (in kernel-mode) and trigger an exception this way
2. I keep the bits in rQ set when resuming, so that these are triggered again
In the first case, mmmix will completely execute the following instruction before triggering the
exception. In the second case, mmmix will also execute one instruction. To me, this makes no sense.
Why should we execute one instruction when we should handle an exception? If the OS requests an
exception, the cpu should simply raise it. I see no reason why we should wait.
The spec does not say how this case should be handled. So I think its legal to do it differently.

2011-02-02:
Found another bug in mmmix. If rV is wrong and we do a load, no exception is raised. Only for
stores. I think the error is in line 4694:
if (page_bad) {
  if (data->i==st || (data->i<preld && data->i>syncid))
     data->interrupt|=PRW_BITS;
  goto fin_ex;
}
The second condition is wrong. Its not possible that data->i is less than preld AND greater than
syncid. I guess it should be an OR instead of an AND. But I'm not sure what the whole intention
behind the condition is. So I better keep it that way.

2011-02-02:
Found another bug in mmmix :) If we do a LDVTS that unsets the readable-flag, for example, the
pipeline seems to need a while before this information is used. That means, directly following
load-instructions will succeed. Instructions that are "far enough away", won't.
This happens when doing a "SYNC 6" (empty TCs) as well. It needs a few cycles until the entries
are removed from all caches. A bit strange is that an entry that was in the DTC before is reported
by LDVTS to be in ITC after SYNC.
I'm not really sure if thats a bug. Is it possible that this behaviour is intended? So that we have
to drain the pipeline when doing such things? On the one hand it would be strange having to issue
a "SYNC 0" after those things. On the other hand, perhaps in most cases it is not really necessary
do be able to see the effects immediatly. BUT at least, those things would HAVE TO be documented
in the spec!

2011-02-04:
I decided to change the union sInstr. Until now it contained a struct for each argument-format.
The problem is that this makes it difficult to put the arguments of the current instruction into
rYY and rZZ. Its much simpler if we have a single struct with x,y and z as octas. This is enough
for every instruction. The disadvantage is of course that these are generic names and therefore
less descriptive than in the old version. But it makes it also simpler at multiple places.

2011-02-04:
Implemented RESUME_TRANS and noticed that this doesn't work yet in mmmix. mmix-doc.pdf says:
	The program assumes that the ropcode in rXX is 3 (which it is when a forced trap is triggered
	by the need for virtual translation).
So, MMIX should do that, but actually it doesn't. That means, if f in rV is set to 1, it does not
set the ropcode to 3 in rXX when a page-fault occurs. It does so when setting hardware_PT via
configuration to 0. Therefore I simply extracted f from rV and stored it in page_f and added an
"|| page_f" to the conditions in which hardware_PT was used. This way it worked.

2011-02-08:
While writing the test-generators for floating-point multiplication, division and addition, I
noticed some interesting differences between MMIX and the x87 FPU of x86. At first, since the
meaning of the sign for NaNs is not specified by IEEE-754, the behaviour is different. And I
noticed, in my opinion, a bug / wrong behaviour of the x87 FPU. Because adding to big numbers or
dividing a number by a very small number or other kinds of operations where the result is bigger
than DBL_MAX, will lead to DBL_MAX. This is wrong, IMO, because the actual result is bigger than
DBL_MAX, so that the result should be INF. And MMIX reports INF.

2011-02-08:
I've integrated a coverage-test. At first I browsed the web a bit to see if there are good tools
for visualizing the output of gcov. As it seems, there aren't a lot of tools around. The only
thing I've found is ggcov. It works, but the user-interface is, well, ugly ;) Additionally I think
we're more flexible when we have our own solution.
Therefore I decided to write a shell-script that coordinates the runs of my simulator and the usage
of gcov and write ruby-scripts to generate html-files. This way we can view the results very
comfortable in the browser. The current version allows it to generate coverage-results for
individual tests but also a complete coverage. Its not perfect yet, but hey, we've everything in
our control, so we can improve it ^^

2011-02-09:
I've changed the breakpoint-stuff. Now we have a more general solution. We can force a break if
a virtual or physical address is accessed for any type of rwx. So, for example we can use
"b v x #2000" so set a "normal" breakpoint to the virtual address #2000. Or we can break as soon
as the machine writes to a specific address.
Additionally, we have expression breakpoints. That means, we can force a break as soon as the value
of an arbitrary expression changes. Even ranges are supported. So, e.g. we can break as soon as
$[1..4] changes.
Unfortunatly the "address-breaks" break BEFORE the instruction that accesses the memory-location
and the "expression-breaks" break AFTER the instruction has changed the expression. I think the
former is necessary because everyone is used to it. If I set a breakpoint @ #2000, I expect that
the machine breaks as soon as an instruction should be executed at that address. That means, before
it is executed. The latter is necessary because it is difficult if not impossible to determine
in advance whether the expression would change.
Therefore I decided to do it that way. A common break-concept would be nicer, but we can live with
the current behaviour, I think.

2011-02-12:
I decided to integrate floats into the language. For several reasons:
- its more flexible than adding a special float-command
- it does not complicate the language very much
- currently strings may only contain a-zA-Z0-9_, so that it isn't even possible to give a special
  float-command a float-literal as a string
I think we still have a simply and clear concept. The only addition is that float-literals are
allowed, so that we have 3 data-types: int, string and float. And of course we allow some operations
on floats (add, sub, div, mul, ...). For these operations ints are converted to floats if one float
is involved. Thats it. The rest is the same.
Of course, not all commands allow floats. ATM only print and set. And of course, floats do not
support all operations integers support. That is, bit-operations, ranges and fetches. Since that
wouldn't make sense.
The question arises whether we should add more operations like fcmp, fcmpe, feql, fsqrt and so on.
I think this would blow the grammar up too much. Because we already have quite a few operations
and those are rather special ones. So, IMO its better to provide a special float-command for that
which provides these operations.

2011-02-14:
Found another bug in mmmix. When executing FREM with "trivial" operands, no exceptions were
triggered because the bits set in "exceptions" were not passed to data->interrupt. So, adding the
missing "data->interrupt |= exceptions;" in line 6137 fixes this bug.

2011-02-15:
I decided to remove single-line-comments from my CLI-language. Because it seems to be not that
easy to use newlines as command-separator, whitespace as argument-separator AND allow single-line
comments. The reason is that SLC can lead to multiple newline-tokens in a row. Suppose we have a
newline, then a comment and then a newline again. This would lead to 2 newline tokens in a row.
How should we handle that? Perhaps we could merge them, but thats no good solution.
Therefore, I decided to leave them out. They're not really necessary anyway. When using the language
interactively, they're completely useless and in scripts, I think, we don't need them, either.

2011-02-16:
Fixed the conceptual bug of mmix that the stack can't grow on demand. My basic idea to fix that is
to give the kernel a different stack than the user. We need some kind of special-register to give
the kernel the possibility to configure the kernel-stack-address. This is necessary because the
kernel can't setup an address when an exception happens because it would have to use registers
(used by the user-program). Of course it would be possible to dedicate a global register to it. But
that would decrease the compatibility to the original MMIX. Therefore I've introduced a new special-
register (rSS).
There are still some ways to deal with it:
1. Set the new stack as soon as a forced and/or dynamic trap is issued
   This would mean that basically all programs that use traps are potentially incompatible.
2. Introduce new instructions
   We could offer an alternative to SAVE and UNSAVE which switch the stack and store/restore rO/rS.
   But this would mean that we need two more instructions. We already have 256 and thus use 1 byte
   to encode the opcode. So, this would change the whole instruction-encoding!
3. Modify SAVE & UNSAVE
   But there is a third way: Modify SAVE and UNSAVE so that they provide two behaviours. This is
   possible because two of the 3-operand-bytes are still unused. Therefore we can dedicate one byte
   to specify whether the default or new version should be used.
   It works like the following:
   SAVE will first backup rO and rS and then change rO and rS to rSS.
   This way, we setup a new stack. All values are saved on that stack. Additionally to all the
   special registers that are always saved, rO and rS are saved.
   UNSAVE will restore rO and rS to temporary variables during restoring special registers. At the
   end it will set that rO and rS so that the stack is in the same state as it was before SAVE.
So, the OS can use SAVE $X,0 (default version) to save the state of a process "in the kernel"
before switching to another process via UNSAVE 0,$Z. This is necessary because in this case we don't
want to switch the stack. When a forced or dynamic trap is issued, the first thing we do is a
SAVE $X,1 to switch to the stack designated by rSS and save the state of the running process on that
stack. Afterwards we handle the interrupt and finally we do a UNSAVE 1,$X to restore the state of
the process and switch back to its stack.
Note that the kernel may use the values of rO and rS, stored on the kernel-stack at the beginning.
I think with that solution we have reached 3 goals:
1. The problem is fixed
   Since the kernel uses a different stack when doing SAVE $X,0 at the beginning to save the state,
   the state is not lost, even if the user-process caused a page-fault when accessing its stack. The
   kernel can simply extend the stack (=map a few more stack-pages), resume the user-process which
   will repeat the last instruction and everything will be fine.
2. GIMMIX is still (nearly) compatible with MMIX
   That means, we'll be able to run (nearly) all programs designed for MMIX on our GIMMIX. Of course,
   programs for GIMMIX that use this feature won't run on MMIX (illegal-instruction exception).
   To the "nearly": Unfortunatly, we will not be able to run programs that have rG < 33. Because
   we have one additional special register (rSS=32), which will be in g[32]. But I think we have
   enough global registers (225), so that it won't be a problem, because nearly no program will
   need so many global registers.
3. The architecture is still clean and elegant
   That means we haven't sacrificed the elegance of the architecture for being able to fix that
   problem. For example it would also be possible to "misuse" another extendable instruction to
   set a "hidden register" (our rSS), so that we have it but still have only 32 special registers.
   That would have given us compatibility, but we would have lost a bit of the elegance because
   it wouldn't fit into the architecture.
So, with our way we do a compromise between elegance and compatibility.

2011-02-17:
I decided to change the display-effects-implementation of the register-stack-loads and -stores. The
old way was to save rS and other special registers before the instruction and calculate the changes
by the executed instruction, the change of rS and other stuff. To support all kind of actions and
work correctly, it got really complicated and error-prone. Therefore I decided to go a different
way in this case. I introduced the EV_STACKLOAD and EV_STACKSTORE that passes all necessary
information to the listener. It turned out that its enough to pass a type and an index with it.
This way, the register-implementation is a bit more complicated and contains code for the CLI
(indirectly), but its really minimal. And, most important, the effects-implementation is really
simple and straight forward.
Ok, I've cheated a bit. I left out the display of the affected dynamic register when a local
register is loaded or stored. Because its not that trivial to calculate the number. But I think,
for my project its not really important.
Another advantage is, that we can easily display the effects when exceptions occurr. That means, if
we do a SAVE for example and the SAVE causes an exception at an arbitrary position, we can display
the actions that have been done so far. Because we simply get no further events after the exception
occurred. Before that, we can be sure that it was successfull.

2011-02-22:
Finally, I've managed to implement the conceptual-fix. It was a bit more complicated than I
thought :) Because in SAVE we can't completely switch the stack before saving the state. The reason
is that reg_stackStore use S as an index to local; i.e. we can't change S before we've saved the
local registers. But we have to change rS because, obviously, we want to store them on the new stack.
The same thing in UNSAVE. We need to set S before restoring the local variables to new user-stack-S.
But we have to keep rS point to the kernel-stack. That does also mean that we have to know the
correct value of S on the user-stack. I've achieved that by not storing the old rS before SAVE'ing
in SAVE, but the value that we need before the first local register is restored * sizeof(octa).
This way, we can calculate the S at that point by simply dividing it by sizeof(octa). The final
value of rS is simply calculated by multiplying S by sizeof(octa) again, after all values have been
loaded from kernel-stack.
There is another thing to take care of: Obviously we have to save all local registers (including
the ones that have been pushed down but not yet stored) in SAVE, as usual. But, since we've saved
them in the change-stack-version on the kernel-stack, we HAVE TO reload all of them immediatly back
into the local registers. Otherwise they would be lost because we continue with the user-stack.
This is not necessary in the default version because we keep the stack and can restore them as soon
as we need them.
And, finally, a third thing to consider: Of course, we want to allow the operating system to use
nested interrupts. So, it should be able to enable interrupts/exceptions in kernel and handle them
immediatly. There are multiple ways to achieve that:
1. We could force the kernel to change rSS before re-enabling interrupts. This way, he can allow
   nested interrupts. Of course, he has to make sure that every kernel-stack in that chain is big
   enough.
2. We could force the kernel to put the kernel-stack in the privileged address-space. If we do so,
   we can just change the stack if we're moving rS from unprivileged to privileged address-space.
   So, if a nested interrupts occurs, we would simply keep the stack. And of course, just if the
   change-stack-version of SAVE/UNSAVE is used.
I think the second option is the better one. Because IMO its not a good idea to put the kernel-stack
in the user-area anyway. Therefore its no problem to require that it's in kernel-area. The advantage
is that we need less memory for it because the layers can be put directly one after another. And
I think its a bit cleaner as well.
It is implemented by setting the LSB of the upper part of the rG/rA octa that is saved last on the
stack when we've changed the stack. Because UNSAVE has no way to determine that. Therefore we
encode it this way. Since this octa is loaded at first, we know in UNSAVE at the beginning what to
do. Note that there is no compatibility-problem because thats just done for the change-stack-
instructions. So, we can do everything we want. To waste no space, its put in that value because
there is some space left.
I've also thought about a way to allow the kernel to use the mapping for itself. Theoretically it
would be possible to dedicate only 3 segments to the user-space and use the fourth segment for the
kernel. The kernel could change rV when entering kernel and change it back when leaving. This way,
in userspace this segment would be empty, but not in kernelspace. Unfortunatly, since we can't use
registers before saving the user-state, we can't use that for the kernel-stack.

2011-02-22:
I just had the idea that we don't need to put the special registers in the same array as the global
ones. Because thats not specified. The only thing that is specified is that G can't be smaller than
32. So, we can put the special registers in their own array and therefore be COMPLETELY backward
compatible to MMIX :)
But, of course, its not that simple. Doing so has the problem that g[...] in the CLI either can't
access the first global register or the last special register. Therefore we need a new construct
to access special-registers. Unfortunatly, we can't use "s" because thats used for step, for example.
I think, we can't change the name of the step-command since everybody expects it to be "s".
Therefore I decided to use "sp" for accessing special-registers. Finally, I think it works really
well and is very clean.
At the moment, the first 32 octas in the global-array are unused. Of course, we could substract
32 from rno everytime we want to access the global registers. But I think its not worth it. If we
want to implement that in hardware, we should do that, of course. But in the simulator its not
really important and its easier to understand it the way it is.

2011-02-25:
Found another bug in MMMIX. MMMIX assumes that the destination register of CSWAP is < rL. Because
it won't increase rL, if necessary. Ok, perhaps one could argue that it makes no sense to pass an
uninitialized register to CSWAP since that register is used by CSWAP. But I would say, it is wrong
to assume that. Because maybe someone needs a zero in that register and MMIX defines that a register
>= rL will always yield 0. Therefore it IS valid to pass an uninitialized register to it, IMO. And,
even it we define that it is not valid, the machine has to trigger an exception (breaks rules).
Therefore, the behaviour of MMMIX is wrong. Unfortunatly I haven't found out yet how to fix that.
setting the flag "X is dest bit" in the flags-table for that instruction is not enough because I
think the operands are switched in this case. Because if we do that, not 1/0 will appear in $X but
the value at M8[$Y + $Z]. So, it seems that more changes are required.

2011-03-01:
IMO its really strange that we're storing the exception-bit that caused the dynamic trap into rXX.
When an interrupt happens, nothing is stored there. At least, I've understood that in this way.
Wouldn't it be much more useful to store the interrupt/exception-number in that byte? That means,
0..63, depending on the bit in rQ that triggered the dynamic trap. Because, we handle one interrupt/
exception at a time anyway and this would be much simpler and faster. The OS could simply use that
number for a function-pointer-table to call the corresponding handler. With the current concept,
the OS has to check every bit in rQ, beginning on the right, to determine what bit caused the
trap. Ok, binary search would be possible, but equally slow and inconvenient.
So, the question is: what's the reason for the current concept? Is there a good reason? Or has Knuth
overseen this issue? Or is there a problem with my idea?
Update: Yes, I've missed something. Its very easy to figure out the reason for the interrupt:
GET $0,rQ; LDOU $1,savedK; AND $0,$0,$1; SUBU $1,$0,1; SADD $2,$1,$0; ANDN $1,$0,$1
So, the OS could use that to determine the bit that is most-right in rQ. I think the reason for
the exception-byte in rX is that the OS can use that to determine quickly whether its an exception
or an interrupt.
But still, its strange that explicitly caused exceptions won't set the byte in rX. I don't know
whats the reason for that. I see no sense in it. Ok, assuming that its not possible to set multiple
exceptions at once, the only opportunity would be that the OS has set it itself or hasn't handled
an exception in the last trap-handler. So, in practice, I guess, it should never happen. But anyway,
its weird that MMIX doesn't provide that in any case. Because: what do we benefit from not doing
that?

2011-03-02:
Perhaps, I miss something, but wouldn't it be better to make the saves and restores of trip/trap &
resume more symmetric? As far as I've understood it, currently it works in the following way:
trip: g[rB] = $255, $255 = g[rJ]
resume 0: -
trap: g[rB] = $255, $255 = g[rJ], g[rK] = 0
resume 1: g[rK] = $255, $255 = g[rB]
So, a trip does store $255 and rJ, but the associated resume does not restore them. Instead, the
handler has to do that. A trap does also store $255 and rJ and clears rK. But in this case, resume
does restore rK and $255. But rK hasn't been saved and it has to be put manually into $255 before
resuming. And perhaps rJ would have to be restored manually as well.
An alternative concept would be:
trip: g[rB] = $255, $255 = g[rJ]
resume 0: g[rJ] = $255, $255 = g[rB]
trap: g[rB] = $255, $255 = g[rK], g[rK] = 0
resume 1: g[rK] = $255, $255 = g[rB]
This way, it would be nearly symmetric and more clear. The trip-handler would have to do
nothing more than a PUSHJ to the actual handler and a RESUME 0. The trap-handler is not forced to
set rK before resuming. Of course, it can by setting $255. It would be possible to save and restore
rJ in traps as well. This way, we could begin a trap-handler with a PUSHJ/PUSHGO. Although its not
very usefull since it has the dynamic-stack-extension-problem.
Perhaps, it would be slightly less efficient because we would do these stuff in all cases. In the
other version, we're not forced to do all actions. And, we might store rK although its not needed.

2011-03-04:
Implemented the device-infrastructure. I decided to do it in a, hopefully, hardware-near way. Thus,
I've implemented a bus which is the entry-point to the devices. Devices have to register themself
to the bus. A device has a name, an address-range and a reset-,shutdown-,read- and write-function.
This way its completely generic, so that the bus can provide generic read-function, for example,
that determines the desired device by the address and delegates the request to that device.
The following decisions have been made:
- every device specifies its address-ranges by itself. But, the address-ranges are defined in one
  file. this way, we have an overview over all devices, but its still (more or less) extendable.
  Because, there won't be third-party vendors that plugin devices. But still, it makes sense to
  have a generic device-interface and allow it to add and remove devices in an easy way.
- read and write always produce/receive an octa. the bus handles the byte-,wyde- and tetra-access in
  a generic way. That means, when storing it will first load an octa, replace the corresponding
  part and write the octa back. When reading, we'll always read an octa, but extract the desired
  part. Additionally every device can specify whether it wants to support non-octa-access.
  This way, the device-implementation is easy (our current devices, except RAM, won't support non-
  octa-access anyway) and the probably common part of handling byte-access and so on is extracted
  into the bus.
- the physmem has been rewritten as a RAM-device. I think, thats a more elegant solution because its
  the same as all other devices, except that the address-range is not in the IO-space. Of course,
  this device allows byte-access and so on. Additionally, its probably more realistic, because the
  RAM is of course attached to the bus as well.
- the effects-command has been extended so that device-access is display, too. This is done by
  firing events on device read/write in the bus. The problem is that, without further actions,
  every instruction-fetch would cause a RAM-read-event. To prevent that I added flags to the effects
  command that specify what special actions should be displayed, including "effects during fetch".
  I think thats a good solution.

2011-03-09:
Found a bug in mmmix. The doc says:
	If the corresponding enable bit is 0, the corresponding event bit is set to 1. But if the
	corresponding enable bit is 1, MMIX interrupts its current instruction stream and executes a
	special "exception handler." Thus, the event bits record exceptions that have not been "tripped."
So, if for example float-overflow and float-inexact have been issued, float-overflow has priority
(because its more left than inexact). Therefore, float-overflow causes a trip to the corresponding
position. But, the inexact-bit has to be set in the event-bits, even if the enable-bit is set (so
that a trip should happen). Because the trip has not been taken. The simple simulator does it in
that way, but the pipeline-sim doesn't.
I fixed that by adding the following line after calculating the position to go to in m:
data->arith_exc |= (j & ~(0x10000 >> (m >> 4))) >> 8;
So, basically we're removing the bit of the trip we're taking from j (all bits) and putting the
remaining ones into rA.

2011-03-11:
Found another bug in mmmix. The doc says:
	For example, after an interrupted store instruction, the first operand rY will hold the
	virtual memory address ($Y plus either $Z or Z), and the second operand rZ will be the
	octabyte to be stored in memory (including bytes that have not changed, in cases like STB).
	In other cases the actual contents of rY and rZ are defined by each implementation of MMIX,
	and programmers should not rely on their significance.
I would say, this enforces each implementation to put the virtual address in rY and the octabyte
to be stored including bytes that have not changed into rZ (for stores). But mmmix does not put
the octabyte to store into rZ at all. I haven't found out how to fix that, but according to my
interpretation of the specification its wrong.

2011-03-11:
Changed the bus and virtmem. I realized that, for example, when storing a byte to memory, so that we
have to load the octabyte first and put the byte into the corresponding position, the read has to
trigger an exception as well, if its not readable. So, its wrong to put this stuff in the bus, i.e.
on the physical side.
Therefore I moved it into the virtmem-module. So, for vm_writeByte we load the corresponding octa
first, put the byte at the corresponding position, and write the octa back. Additionally, we have
to put the octabyte that should be stored into rZ when an exception happens during the store.
There is even more to take care of: If we should write a byte, there are 4 different sitations:
1. the memory is not readable and not writable
   in this case, we would fire both exceptions, i.e. PROT_READ and PROT_WRITE.
2. the memory is not readable, but writable
   this would just set PROT_READ
3. the memory is readable, but not writable
   this would just set PROT_WRITE and would set rZ to the octabyte to store
4. the memory is readable and writeable
   this would succeed
That means, making a page writable but not readable ensures that nobody can access bytes, wydes and
tetras on that page. Just octa-accesses are allowed.
To achieve this, I gave tc_translate another parameter, that specifies what bits should be present
in the PTE so that no exception is thrown. We need that because when reading for a store, we don't
want to fire an exception if its not writable. But, if its not readable we want to fire PROT_READ
*and* if its also not writable PROT_WRITE as well. So we need the information for what purpose the
access is and what bits should fire an exception.
Additionally, that has the consequence that we can't access non-octas on physical memory. Therefore
it has been removed in the CLI-language. This does also mean, that all devices can be accessed
byte-wise and wyde-wise and tetra-wise. But not the device will handle that, but the virtmem-module.

2011-03-13:
Just realized:
	Page table entries should be writable only by the operating system. The 16 ignored bits of x
	imply that 	physical memory size is limited to 2^48 bytes
That means, its not possible to map devices for user-apps. This might be useful for microkernels
that want to run device-drivers in user-mode.
Should we change that? Or does that require more changes than not ignoring the upper 16bit of PTEs?

2011-04-04:
It would be nice if MMIX would provide some information about itself, for example via memory-mapping.
Interesting for software would be the amount of main-memory, cache-block-size, cache-size, ...

2011-04-04:
Implemented caching. I've decided to keep it simple, but complicated enough so that all facilities
that MMIX offers for the software can be implemented in a reasonable way.
To be concrete, we have a fully associative, write-back, write-alloc cache with random replacement
policy and without victim cache. Reasons:
- fully associative: simplicity
- write-back: writing all data directly to memory wouldn't make much sense because the difficulties
  for the OS regarding when to flush the cache would be gone.
- write-alloc: this way we load data from memory first we should write and it isn't in cache yet.
  I think it makes it more transparent and consistent, because all data is in the cache first and
  this does not depend on unpredictable conditions in the cache.
- random replacement policy: simplicity; to make it more predictive we don't use the cycle-counter
  but our own counter in the cache (0,1,2,...n-1,0,1,...)
- without victim cache: simplicity; isn't really necessary and the software won't see the difference
Additionally the block-size and cache-size of IC and DC is configurable by constants because it
doesn't make it more complicated and makes sense to be able to change that afterwards.
To the actions of the system-instructions:
LDUNC: we request MEM_UNCACHED to our memory-hierarchy. it means, if its already in the cache, use
  that value, but if not, load it from memory and don't put it in the cache.
STUNC: we request MEM_UNCACHED as well. that means, if its already in the cache, fine, simply change
  the value. If not, don't load it from memory, but write it directly to mem.
PRELD: we simply request the specified range from memory and therefore load it into the cache.
PREGO: the same, but we use vm_readInstr to use the instruction-cache
PREST: we request MEM_UNINITIALIZED. that means, if its already in cache, do nothing, if not, don't
  load it from memory, but zero it. Because we can assume that the software will write it first
  before reading it.
SYNCD: in user-mode: flush data-cache; in kernel-mode: remove it as well
SYNCID: in user-mode: flush data-cache and remove entries from IC; in kernel-mode: clear both caches
This implementation are not always identical to the behaviour of MMIX-PIPE, but it should be the
simplest interpretation of mmix-doc.
These changes adds some more parameters to the memory-hierarchy, so that I've decided to remove the
boolean sideEffects and use flags instead. we have 4 flags atm, MEM_SIDE_EFFECTS, MEM_UNCACHED,
MEM_UNINITIALIZED and MEM_IGNORE_EX. that makes the whole thing more complicated, but I think the
approach is still clear and understandable.

2011-04-05:
Another thing came to my mind: mmix-doc says for some system-instructions:
  No protection failure occurs if the memory is not accessible.
Its not 100% clear what this means, IMO. But I would say it means that just protection-faults are
ignored, i.e. if read-, write- or execute-permission is needed but missing. All other kinds of
exceptions that are possible will be reported. For example, a non-existing-memory-fault can occur
if we use an address in the IO-space that isn't used. MMIX-PIPE doesn't seem to fire these traps
at all. But we do.
The question is, of course, whats the background of ignoring these exceptions. I guess the idea is
that these exceptions should only fire for load/store-instructions (simplicity for the kernel?).
Additionally, its not specified what exactly an MMIX-implementation should do. Some might do nothing
at all. But I'm still not 100% convinced of this explanation...
However, I think only protection-faults are included because other exceptions would mean a bug in
the program. So, for example non-existing memory or privileged address. These kinds of exceptions
occur every time, depending on nothing. I.e. the program is really wrong and should be terminated
anyway. On the other hand, a protection-fault depends on the PTE's and the TCs. These may indeed
change and don't necessarily mean a bug in the program.

2011-04-07:
I've decided to let m[...] access the bus directly and ignore the caches. This way, we can examine
the state of all devices in the memory-hierarchy. Because we can use the privileged space in virtual
memory to access the caches. So, if we want to make a change in physical memory visible to the SW
we should do it this way, because the cache will be updated, if the memory is already present there.
Equally, we'll see things from the cache, if its present there, when reading.
On the other hand we can use m[...] to view or change whats in the physical memory (RAM or other
devices). We can examine the caches via dc and ic.
It may be a bit confusing first, but I think its better to do it this way for the mentioned reasons.

2011-04-07:
I've decided to make all "detailed" configurations changeable by constants in code. So, for example,
number of local registers, instructions per msec, cache-size and so on. Other things that may be
changed in hardware-implementations as well or are really important, can be changed by command-line-
arguments. This way we can say that the build-process builds a piece of hardware that can't be
changed. But some things like number of terminals, harddisk and other things can be changed by
command-line-arguments because we would be able to add/change that in a HW-version as well.

2011-04-13:
I've decided to keep the RAM-implementation as it is. Because:
1. it does already work
2. its a bit nicer than the simple one because we only pay for the memory if we need it
3. the user-mode-settings require us to have roughly 32 GiB RAM. this is not achievable with the
   simple approach
Therefore we use the treap-thing of Knuth. Additionally the user can now specify the amount of
main memory via command-line-parameter.

2011-04-13:
The reasons for the config-module are:
1. it allows us to have no arguments for the init-function of all modules. otherwise some of them
   would require arguments and others won't.
2. its used for checks as well and is therefore a good abstraction and separation of concerns
3. it is used for the reset-procedure. some settings are needed for that. for example, if we have
   to load a program we have to do that again.

2011-04-16:
Idea for scripting: If I would like to improve the performance of, lets say, a function, I could
write a program that calls this function with many different arguments, so that various cases are
covered. Then I can write a script that executes the code and measures the performance with stat.
I can do that by a sequence of "so 3, st, str, so 3, ..." or similar. Then, simply run the simulator
with that script, pipe the result to a file and analyze it with some unix-tools. This way, I can
analyze the performance of a function for various calls of it automatically. That means, I can
improve the performance step by step by changing something and running this procedure again. I can
not only analyze the number of instructions. I can also analyze the TC- and cache-utilization and
other things.

2011-04-29:
I decided not to implement ruckerts solution for the stack-fault-problem. Although in the end it
would be a good thing, because it offers more flexibility to the OS and allows the OS to handle
interrupts or exceptions more efficiently.
But implementing it now would mean to break the compatibility with the current MMIX architecture.
Because we would have to define that rG is at most 224 (or similar) and that the OS HAS TO make sure
that no processes will run for which rO or rS is not mapped. Not only, that these are of course
restrictions one can argue about, it would break the compatibility. Since the "official" solution
for that problem has not been decided yet, its not clear how exactly it will be. Therefore, its
better to choose a solution that is backwards compatible. Because, no one knows when the official
solution will be available.
Additionally, specifying that rG is at most 224 would mean that many tests would have to be
reconsidered completely. Because some of them rely on the value or rG (255). Thus, to ensure that
all tests do what they are supposed to, we would have to check them all again. This would be a big
effort and I think its not worth it.
But I had tested the implementation of ruckerts version for a short period of time. It should be
sufficient to check rO in PUSHJ. More precisely, we need to do that only if the page of rO changed.
Because we always assume that rO is currently mapped. It has not to be checked in POP, as ruckert
said, but for a different reason. Not because there is only a read (he said write, but I guess he
meant read) if rS == rO, but because rO does never get less than rS. Thus, decreasing rS may lead
to a page-fault, but thats ok, because we can still handle it. If rS has been decreased successfully,
rO can't cause a page-fault, because it will never move past rS. That means, its always between the
old rO and the new rS.
Furthermore, we have to check the read/written range in SAVE/UNSAVE. But this is not specific for
ruckerts solution, but has to be done anyway.

2011-04-29:
A few days ago, I discovered a problem, that GIMMIX needs to take care of. It is wrong to make sure
that every instruction can be repeated if it causes an exception. This condition is not strong
enough. Because the OS may choose to handle a signal instead. Thus, the control-flow may change
and therefore we need to make sure that every instruction will leave MMIX in an consistent state.
This sounds like it is always the case anyway, but it is not. The old version of POP did not leave
MMIX in an consistent state if a read failed. Because values could have been read from stack into
the registers, but rL wasn't decreased. This can lead to problems if POP is not directly repeated,
but for example a PUSHJ, ..., POP is done previously. This would destroy the state of the program,
because the value of rL is too high. For example, the consequence could be that PUSHJ or any
following instructions overwrite the number of registers to POP, which had already been read by
the failed POP. But since rL has not been decreased, other instructions may simply overwrite it.
Of course, repeating the failed POP will not reread it from stack, because the stack-pointer has
already changed when the POP failed.
So, long story short: rS had been decreased, but rL not, leading to an inconsistency. Therefore
rL is decreased now, which makes sure, that the state is consistent and thus other instructions
can be executed before retrying the POP. Of course, this removes local registers of the function
that used this POP. But we can't continue the function anyway and we will not remove the returned
values. Thus, all values that have to be kept, are kept. In other words, it would of course not be
valid, if a POP causes an exception and the OS exchanges this instruction by another one, so that
the function is continued. But, as said, the OS might choose to handle a signal. I think, this must
be allowed. At least, MMIX does not say the opposite.
For the same reason, UNSAVE was not correct previously. Because it could be repeated, but it may
have already changed something (special registers, global registers, ...), so that its not really
possible to handle a signal or something. Since, in this case, we can't simply catch an exception
and restore a hand full of values, like we did in SAVE before this change, a different solution
has to be found. I think the best way is to check both in SAVE and UNSAVE whether the instruction
will succeed, before doing anything. This way, obviously, the problem is solved. Unfortunatly, this
requires a calculation of the accessed address range, we need to get the pagesize and read and write
on each page. I've decided to read and write in all cases, because it makes it simpler. Additionally,
I've decided not to do that in privileged space, because the only thing that can happen is
non-existent physical memory, from which we can't recover anyway. Furthermore, it is not done at all
when changing stack, for the same reason (rSS is always in privileged space).

2011-06-03:
I've decided to add the possibility to disable the effects-command. Because when developing with
GIMMIX, it is started in interactive mode, i.e. all event-handlers are registers. Unfortunatly,
the effects command doesn't know whether the user will use it after the current instruction. That is,
it has to assume that the user will do that and is therefore forced to track the effects of all
instructions. Of course, this takes some time (on my system it is roughly 30% of the total runtime).
Therefore, I think, it is useful to provide a way to disable that, while still using the interactive
mode and enable it later when needed. There should be two basic usages of the interactive mode:
1. We're currently debugging and want to see the effects of most of the instructions.
2. We want to run the OS, but maybe a situation arises, that requires us to inspect what's happening.
To provide an acceptable solution for both cases, I've decided to enable the effects by default in
interactive mode (nice for situation 1). In situation 2 we can start GIMMIX with a script, that
disables the effects at the beginning. This way, it runs more quickly and if we want to analyze
something later, we simply enable the effects.
For the same reason, I've decided to make stat deactivatable. It doesn't take that much time as
effects, but its still a lot (5-10%). Therefore, its enabled by default, but can be disabled.
Additionally, enabling it resets the stats.