arithmetic exceptions:
===========================

rA:
64      56       48       40       32       24       16        8        0
+--------+--------+--------+--------+--------+--------+--------+--------+
|        |        |        |        |        |      RR|DVWIOUZX|DVWIOUZX|
+--------+--------+--------+--------+--------+--------+--------+--------+
|<-                   reserved (=0)              ->|    enable    event

D = integer divide
V = integer overflow
W = float-to-fix overflow
I = invalid operation
O = floating overflow
U = floating underflow
Z = floating division by zero
X = floating inexact

RR = rounding-mode:
 00 = nearest (default)
 01 = round off (toward zero)
 10 = round up (toward positive infinity)
 11 = round down (toward negative infinity)

enable-bit = 0 => set event-bit
enable-bit = 1 => interrupt current instruction and continue with exception-handler
first enabled exception takes precedence


trip and trap:
==============

"TRAP X,Y,Z" is handled by the OS
	if XYZ = 0, a user-process should terminate
	if XYZ = 1, the OS should provide default action when a user-handler is not present
"TRIP X,Y,Z" is handled by the user

When an interrupt happens, the current instruction may or may not have been completed. Registers:
	rX = instruction; programmers should not rely on this, as it may be something different
	rY = operand 1 (if there is any); programmers should not rely on this, as it may be something different
	rZ = operand 2 (if there is any); programmers should not rely on this, as it may be something different
	rW = address of following instruction
rX is not necessary the same as the instruction at (rW - 4). E.g. it may be a jump to rW. Or an
inserted instruction by the MMIX processor.

Trips:
------
A TRIP instruction puts itself into the right half of the execution register rX, and sets the 32 bits of the
left half to # 80000000. (Therefore rX is negative; this fact will tell the RESUME command not to TRIP again.)
The special registers rY and rZ are set to the contents of the registers specified by the Y and Z fields of the
TRIP command, namely $Y and $Z. Then $255 is placed into the special bootstrap register rB, and $255 is
set to rJ. MMIX now takes its next instruction from virtual memory address 0.

Arithmetic exceptions interrupt the computation in essentially the same way as TRIP, if they are enabled.
The only difference is that their handlers begin at the respective addresses 16, 32, 48, 64, 80, 96, 112,
and 128, for exception bits D, V, W, I, O, U, Z, and X of rA; registers rY and rZ are set to the operands of
the interrupted instruction as explained earlier.

Instructions in negative virtual locations do not invoke trip handlers, either for TRIP or for arithmetic
exceptions. Such instructions are reserved for the operating system, as we will see.

Forced Trap:
------------
A TRAP instruction interrupts the computation essentially like TRIP, but with the following modifica-
tions:
	- the interrupt mask register rK is cleared to zero, thereby inhibiting interrupts;
	- control jumps to virtual memory address rT, not zero;
	- information is placed in a separate set of special registers rBB, rWW, rXX, rYY, and rZZ,
	instead of rB, rW, rX, rY, and rZ. (These special registers are needed because a trap might occur
	while processing a TRIP.)
Another kind of forced trap occurs on implementations of MMIX that emulate certain instructions in
software rather than in hardware. The trap handler can tell what instruction to emulate by looking at the
opcode, which appears in rXX.
Implementations of MMIX might also emulate the process of virtual-address-to-physical-address translation
described below, instead of providing for page table calculations in hardware.

Dynamic Trap:
------------

Interrupt request register rQ / interrupt mask register rK:
64      56       48       40       32       24       16        8        0
+--------+--------+--------+--------+--------+--------+--------+--------+
|        |        |        |rwxnkbsp|        |        |        |    RMPW|
+--------+--------+--------+--------+--------+--------+--------+--------+
|<-   low priority I/O   ->|program |<-   high priority I/O  ->| machine|

program bits:
 r: instruction tries to load from a page without read permission;
 w: instruction tries to store to a page without write permission;
 x: instruction appears in a page without execute permission;
 n: instruction refers to a negative virtual address;
 k: instruction is privileged, for use by the "kernel" only;
 b: instruction breaks the rules of MMIX;
 s: instruction violates security (see below);
 p: instruction comes from a privileged (negative) virtual address.

most urgent interrupts:
 R = reboot
 M = nonexistent memory
 P = parity error
 W = power failure

The low and high priority bits and the rest of the machine bits depend on the MMIX-implementation
and on the available IO-devices.

Once rQ ∧ rK becomes nonzero, the machine waits briefly until it can give a precise interrupt. Then it
proceeds as with a forced trap, except that it uses the special “dynamic trap address register” rTT instead
of rT. The trap handler that begins at location rTT can figure out the reason for interrupt by examining
rQ ∧ rK.

An instruction that causes a dynamic trap is usually executed before the interruption occurs. However,
an instruction that traps with bits x, k, or b does nothing; a load instruction that traps with r or n loads
zero; a store instruction that traps with any of rwxnkbsp stores nothing.


Resume:
=======

