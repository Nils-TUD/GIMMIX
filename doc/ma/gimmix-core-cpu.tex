\subsection{CPU}

As the name suggests, the CPU is the central unit in GIMMIX, that is responsible for executing the instructions, using the help of several other modules.

\subsubsection{Executing an Instruction}

The execution of instructions is separated into three phases:
\begin{enumerate}
	\item fetching the instruction, \ie loading the tetra from memory,
	\item decoding the instruction, which means that the operands are extracted from the tetra and translated into \i{arguments}, depending on the opcode and
	\item executing the instruction, taking the arguments and performing the required actions.
\end{enumerate}
The code in module CPU, that realizes the described procedure, looks like the following:
\begin{lstlisting}[language=C,caption=Executing an instruction (slightly shortened)]
jmp_buf env;
int ex = setjmp(env);
if(ex != EX_NONE)
	cpu_triggerException(ex,ex_getBits());
else {
	ex_push(&env);

	// fetch instruction
	ev_fire(EV_BEFORE_FETCH);
	instrRaw = mmu_readInstr(pc,MEM_SIDE_EFFECTS);

	// decode
	instr = dec_getInstr(OPCODE(instrRaw));
	cpu_checkSecurity();
	dec_decode(instrRaw,&iargs);

	// execute
	ev_fire(EV_BEFORE_EXEC);
	instr->execute(&iargs);

	// handle realtime tasks
	if(++instrCount == INSTRS_PER_TICK) {
		instrCount = 0;
		timer_tick();
	}
	cpu_checkForInterrupt();
	cpu_counterTick();
}
ex_pop();
ev_fire(EV_AFTER_EXEC);
pc += sizeof(tetra);
\end{lstlisting}
As the listing shows, the whole procedure is surrounded by a kind of try-catch-construct, because several parts of it may throw an \glslink{Exception}{exception}. If an \glslink{Exception}{exception} is thrown, it will jump back to the `setjmp` call, which will return the \glslink{Exception}{exception}-number. Afterwards the requested trip or trap is triggered (this will be described in detail later). Additionally, the code fires events at several interesting places to allow the CLI to perform some actions. After the instruction has been executed, realtime tasks are done if necessary (which might result in a finished disk-command or similar), it is checked whether $\sr{Q}\land\sr{K}$ is non-zero and the counters are ticked (\sr{C}, \sr{U} and \sr{I}). Finally, the \gls{PC} is advanced to the next instruction. It should be mentioned, that the function `cpu_checkSecurity` ensures that all program bits are set in \sr{K}, when running in user mode, and that the privileged \gls{PC} bit is \i{not} set, when running in privileged mode.

The actual decoding is done by the function `dev_decode` of the module \i{decoder}. The decoder contains a table, that assigns to each instruction both an \i{instruction format} and \i{argument format}. The first one defines the meaning of the three operand bytes `X`, `Y` and `Z`. The second defines the arguments for the execution-function. More precisely, those functions receive a struct that contains the fields `x`, `y` and `z`, but the meaning of the fields differs, depending on the argument format. For example:
\begin{itemize}
	\item \mi{ADD} (`I_RRR`, `A_DSS`): ${\tt x}={\tt X}$, ${\tt y}=\dr{Y}$, ${\tt z}=\dr{Z}$
	\item \mi{ADDI} (`I_RRI8`, `A_DSS`): ${\tt x}={\tt X}$, ${\tt y}=\dr{Y}$, ${\tt z}={\tt Z}$
	\item \mi{BNN} (`I_RF16`, `A_CT`): ${\tt x}=\dr{X}$, ${\tt z}=@ + 4*{\tt YZ}$
	\item \mi{STBI} (`I_RRI8`, `A_SA`): ${\tt x}=\dr{X}$, ${\tt y}=\dr{Y} + {\tt Z}$
\end{itemize}
In other words, the decoder performs a mapping from the instruction operands to the arguments, which hide certain details from the execution function. For example, the functions that implement the branches will simply receive the address to jump to and do not have to care about jumping forward or backwards and so on. Similarly, instructions like \mi{ADD} and \mi{ADDI} are put together, \ie there is only one execution function for both, because the differences are handled by the decoder.

Besides the fact that the separation of decoding and executing prevents code duplication and is arguably more elegant, there is also a technical reason for it. Because, as described in the previous chapter, the instruction \mi{RESUME} has a ropcode that allows it to execute the typical "set `X` to the result of `Y` OP `Z`" instructions and some other, whereas the operands are taken from \sr{YY} and \sr{ZZ} instead of from the instruction itself. Thus, many instructions need to be executable both in the ordinary and in this special way. Since this separation hides the origins of the operands from the execution function, this is no problem anymore, because when implementing \mi{RESUME}, one can simply create the argument struct from the instruction in \sr{XX} and exchange `y` and `z` with \sr{YY} and \sr{ZZ}, respectively.

\subsubsection{Execution Functions}

The execution functions, mentioned in the previous section, are in most cases very short and simple. Because the arguments are provided in the desired form from the decoder and because other modules like MMU, int, float and register do the hard work. The following listing shows a few examples:
\begin{lstlisting}[language=C,caption=Examples of the execution functions]
void cpu_instr_nor(const sInstrArgs *iargs) {
	octa res = ~(iargs->y | iargs->z);
	reg_set(iargs->x,res);
}

void cpu_instr_stou(const sInstrArgs *iargs) {
	mmu_writeOcta(iargs->y,iargs->x,MEM_SIDE_EFFECTS);
}

void cpu_instr_bev(const sInstrArgs *iargs) {
	if(!(iargs->x & 1))
		jumpTo(iargs->z);
}
static void jumpTo(octa addr) {
	if(!cpu_isPCOk(addr))
		ex_throw(EX_DYNAMIC_TRAP,TRAP_PRIVILEGED_PC);
	// substract sizeof(tetra) because it will be increased
	cpu_setPC(addr - sizeof(tetra));
}
\end{lstlisting}
That means, the implementation of \mi{NOR} simply performs the bit operation and sets \dr{X}, \mi{STOU} uses `mmu_writeOcta` to write `iargs->x` to `iargs->y` and \mi{BEV} jumps to the desired location if `iargs->x` is even. The latter has to check the \gls{PC} first to make sure that no jump from user space to privileged space can be done.

Besides this simplicity, there is an important point every instruction has to take care of. Although all instructions are uninterruptable, \ie an \glslink{Interrupt}{interrupt} can not happen during their execution, of course program \glslink{Exception}{exceptions} can occur. Thus, every execution function (and many other functions as well) has to pay attention to this. In most cases, as in `cpu_instr_stou` above, it is simple because there is at most one function, that might throw an \glslink{Exception}{exception}. Therefore, calling this function at first, \ie before the state has changed, solves the problem. But if multiple functions might throw an \glslink{Exception}{exception}, it gets more complicated:
\begin{lstlisting}[language=C,numbers=left,numberstyle=\footnotesize,caption=Execution function of \mi{CSWAP}]
void cpu_instr_cswap(const sInstrArgs *iargs) {
	octa addr = iargs->y + iargs->z;
	octa mem = mmu_readOcta(addr,MEM_SIDE_EFFECTS);
	if(mem == reg_getSpecial(rP)) {
		octa val = reg_get(iargs->x);
		reg_set(iargs->x,0);
		reg_set(iargs->x,val);
		mmu_writeOcta(addr,val,MEM_SIDE_EFFECTS);
		reg_set(iargs->x,1);
	}
	else {
		reg_set(iargs->x,0);
		reg_setSpecial(rP,mem);
	}
}
\end{lstlisting}
In this case, the functions to be careful with are `mmu_readOcta`, `reg_set` (storing values on the stack might lead to an \glslink{Exception}{exception}) and `mmu_writeOcta`. Obviously, if multiple functions change the state and might throw an \glslink{Exception}{exception}, calling them at first will not work. The following trick does solve the problem for \mi{CSWAP}. The read in line 3 does not change the state (caches are not considered critical in this case) and can thus be called at first. The `reg_set` in line 6 sets \dr{X} to an arbitrary value. If this function throws, nothing will have been changed yet. If it does not, line 7 will set \dr{X} back to the original value, which can not throw because the previous `reg_set` would have already done that. Hence, if the write in line 8 throws, the state will not have been changed yet. If line 9 is reached, `reg_set` will not throw either. All in all, no matter which function throws, the state has not changed (line 12 is not critical here). Additionally, all used functions are assumed to be \glslink{Exception}{exception}-safe as well. It will be described later, that a few functions actually do not garantee to be atomic, \ie do not change the state if an \glslink{Exception}{exception} occurs, but only make sure that a consistent state is reached.

\subsubsection{Arithmetic}

As described, MMIX supports both integer and floating point arithmetic. GIMMIX uses the modules \i{int} for integer arithmetic and \i{float} for floating point arithmetic. The former only implements the operations that differ from the behaviour defined by \glslink{C89C99}{C99}. The latter handles all operations in software, \ie uses the integer arithmetic of the underlying platform. Both -- and especially float -- contain very complicated algorithms, but because they are not the central points of this thesis, they are described only sketchy. Besides that, they have been inherited from MMIX-SIM/MMIX-PIPE and have only been adjusted for GIMMIX. All functions are implemented, so that they are independent of the rest of the simulator. That means, they do not access registers, change the state or similar.

\paragraph{Integer Arithmetic}

The module int contains functions for 128-bit signed and unsigned multiplication and division. They basically break down the operation to the 16-bit or 32-bit multiplication or division of the underlying platform, because 128-bit versions are not available. Additionally, the division has to handle the differences to \glslink{C89C99}{C99}. Because MMIX requires floored division, while \glslink{C89C99}{C99} defines that truncated division is used \citep[pg. 82]{c99std}. Additionally it is worth mentioning, that the signed versions of both multiplication and division are based on the unsigned versions and only adjust the result accordingly.

The three shift types of MMIX -- shift left, shift right arithmetically and shift right logically -- are implemented in this module as well. The reason is, that \glslink{C89C99}{C99} says:
\begin{quote}
If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. \citep[pg. 84]{c99std}
\end{quote}
Thus, the functions implementing the shifts ensure, that for example $1 \ll 65$ leads to zero, as MMIX defines it.\footnote{For example, the result of $1 \ll 65$ with \gls{gcc} 4.4.5 on x86\_64 is 2 instead of 0, because $x \ll y$ does actually mean $x \ll (y \bmod (sizeof(y)*8))$.}

\paragraph{Floating Point Arithmetic}

The basic principle in module float is to use the function `fl_unpack` to extract the components of a float from an octa. It returns a structure called `sFloat`, that contains the sign, the exponent, the fraction and the type (`ZERO`, `NAN`, `INF` or `NUM`). If the number is denormalized, it will be normalized and the exponent gets negative to abstract away the differences. Additionally, the fraction is always shifted left by 2, leading to two zero bits at the end, that are used for rounding and detection of inexact results.

All floating point operations work with instances of `sFloat`. Most of them consist of a `switch`, that does the corresponding action or returns the corresponding value, depending on the type of the operand(s). Finally, `fl_pack` is used to build an octa from the `sFloat` structure, which has represented the result so far. Consequently, it goes the opposite way than `fl_unpack`. It also rounds the result with the requested rounding mode and indicates overflow, underflow and inexact \glslink{Exception}{AEs}, if necessary. These are not directly triggered, but passed back to the caller. As soon as short floats are used, `fl_spack` and `fl_sunpack` are chosen instead of `fl_pack` and `fl_unpack`.

\subsubsection{Register}

The module \i{register} is one of the most important and also most complicated ones. Therefore, this thesis describes it in depth. Obviously, it is responsible for managing the registers. Additionally, it implements the main parts of the instructions \mi{PUSHJ}, \mi{PUSHGO}, \mi{POP}, \mi{SAVE} and \mi{UNSAVE}. More precisely, the parts that affect the register stack. Thus, checking the instruction operands, setting the new \gls{PC} and similar tasks, are done by the execution function, while the rest is done by the register module.

\paragraph{Basic Data Structures and Operations}

The basic data structures and functions of register are quite simple. It has the arrays `local`, `global` and `special` to hold local, global and special registers, respectively. Furthermore, it manages the abbreviations `L` for \sr{L}, `G` for \sr{G}, `S` for $\sr{S}/8$ and `O` for $\sr{O}/8$. The last two are used as indices into `local` and -- instead of what the description of MMIX said -- modulo is not used all the time (\ie in general, ${\tt O} \ne (\sr{O}/8) \land (2^n-1)$), but only if `local` is accessed. In code listings, $2^n-1$ will be called `LREG_MASK`, analogously to `GREG_MASK` for the global registers.

To offer other modules access to the mentioned arrays, the following functions are provided:
\begin{itemize}
	\item `reg_getLocal`/`reg_setLocal`:\\
	These functions return or set the value of the specified local register, independent of `O`. This is not used by the core, but only by the CLI at the moment.
	\item `reg_getGlobal`/`reg_setGlobal`:\\
	These ones return or set the value of the specified global register and are also only used by the CLI.
	\item `reg_getSpecial`/`reg_setSpecial`:\\
	Similarly, these functions return or set the value of the specified special register.
	\item `reg_get`/`reg_set`:\\
	Finally, these two return or set the value of the specified dynamic register, \ie if `rno` is the desired register number, ${\tt rno} \ge {\tt G}$ will denote global register `rno`, ${\tt rno} < {\tt L}$ will denote local register $({\tt O}+{\tt rno}) \land (2^n-1)$ and other values denote marginals.
\end{itemize}
The most interesting function just described, is `reg_set`, which is implemented as follows:
\begin{lstlisting}[language=C,caption=Implementation of {\tt reg\_set}]
void reg_set(int rno,octa value) {
	if(rno >= G)
		global[rno & GREG_MASK] = value;
	else {
		while(rno >= L) {
			local[(O + L) & LREG_MASK] = 0;
			if(((S - O - (L + 1)) & LREG_MASK) == 0)
				reg_stackStore();
			special[rL] = L = L + 1;
		}
		local[(O + rno) & LREG_MASK] = value;
	}
}
\end{lstlisting}
As the listing shows, if `rno` is greater than or equal to `L`, `L` will be increased first and registers will be set to zero. If the registerring is full, \ie if the number of used local registers (plus one to leave a slot free) is equal to the number of available slots (difference of `S` and `O`), a register will have to be written to memory first. More precisely, `reg_stackStore` writes `local[S & LREG_MASK]` to \vmem{8}{\sr{S}} and increases \sr{S} by 8 and `S` by 1.

Similarly to the implementation of \mi{CSWAP}, `reg_set` has to take care of \glslink{Exception}{exceptions}, that might be thrown when writing to memory. But in contrary to \mi{CSWAP}, it does not ensure that the state does not change. Instead, it will always leave in a consistent state. That means, if `reg_stackStore` fires an \glslink{Exception}{exception}, the function might have already increased `L` and cleared some registers. But it is no problem, because the state is ok and the repetition of the instruction will continue at the point just left. To allow that, it is important that the increasing of `L` is done \i{after} storing a value on the stack. Doing it in the other way around would lead to an inconsistent state.

\paragraph{Pushing Registers Down}

The function, that performs the central tasks of \mi{PUSHJ} and \mi{PUSHGO} is called `reg_push` and receives the `X` operand of the instruction as argument. It is implemented in the following way:
\begin{lstlisting}[language=C,caption=Implementation of {\tt reg\_push}]
void reg_push(int rno) {
	int curL = L;
	if(rno >= G) {
		rno = curL++;
		if(((S - O - curL) & LREG_MASK) == 0)
			reg_stackStore();
		local[(O + rno) & LREG_MASK] = rno;	// set hole
	}
	else {
		reg_set(rno,rno);	// set hole
		curL = L;
	}

	O += rno + 1;			// push down
	special[rO] += (rno + 1) * sizeof(octa);
	L = curL - (rno + 1);	// move L down (keep arguments)
	special[rL] = L;
}
\end{lstlisting}
That means, at first the hole is set to `rno` to remember the number of pushed down registers. Afterwards, `O` is increased correspondingly and `L` is adjusted, so that the arguments for the callee are kept. If ${\tt rno} \ge {\tt G}$, `rno` will be set to `L`, `L` will be increased by 1 and a register might have to be written to memory first. Similarly to `reg_set`, the function has to take care of the \glslink{Exception}{exceptions} thrown by `reg_stackStore`. Thus, `L` is not changed before the call to ensure that the state has not been changed if it throws.

\paragraph{Popping Registers}

The implementation for \mi{POP}, which receives the number of registers to return as argument, is a bit more complicated:
\begin{lstlisting}[language=C,caption=Implementation of {\tt reg\_pop}]
void reg_pop(int rno) {
	octa holeData;		// last return value -> hole
	if(rno != 0 && rno <= L)
		holeData = local[(O + rno - 1) & LREG_MASK];
	else
		holeData = 0;	// if rno > L, hole <- 0

	int numRets = rno <= L ? rno : L + 1;
	if(special[rS] == special[rO]) {
		reg_stackLoad();
		if(((S - O - L) & LREG_MASK) == 0)
			special[rL] = --L;
	}
	int numRegs = local[(O - 1) & LREG_MASK] & 0xFF;
	
	while((tetra)(O - S) <= (tetra)numRegs) {
		reg_stackLoad();
		if(((S - O - L) & LREG_MASK) == 0)
			special[rL] = --L;
	}

	L = numRegs + numRets;
	if(L > G)
		L = G;
	// set hole
	if(L > numRegs)
		local[(O - 1) & LREG_MASK] = holeData;
	O -= numRegs + 1;
	special[rO] -= (numRegs + 1) * sizeof(octa);
	special[rL] = L;
}
\end{lstlisting}
At first, the value for the hole is calculated. If ${\tt rno} \le {\tt L}$, it will be set to the last return value, if ${\tt rno} > {\tt L}$, it will be set to zero and if ${\tt rno} = 0$, the hole will not be set at all. Afterwards, the number of local registers the caller wanted to keep, is determined. It might be necessary to load this value back from memory into a register first. Subsequently, if required, local registers will be restored until the desired `numRegs` are available. Finally, `L` is set for the caller, the hole is written and `O` is decreased correspondingly.

Again, \glslink{Exception}{exception}-safety has to be considered. Of course, both calls of `reg_stackLoad` might throw an \glslink{Exception}{exception}. At a first glance one might think that it is sufficient to make sure, that all instructions can be repeated successfully, after the \glslink{Exception}{PE} that they had triggered previously, has been handled. In this case it would mean, that we do not need to care about it, because only a few registers of the caller might have been already loaded and will not be loaded again when repeating the instruction. But unfortunatly this is not enough. Because the OS might choose not to repeat the function directly, but \eg let the user application handle a signal first (or something else, that is asynchronous to the ordinary control flow)\footnote{At least, the MMIX specification does not say the opposite. Therefore it is considered valid to let the user application handle a signal first when leaving the kernel, even if the kernel has been entered because of a \glslink{Exception}{PE}.}. In this case, arbitrary other instructions may be used and thus, the state of MMIX and in particular the state of the register stack has to be consistent. To ensure it in `reg_pop`, `L` has to be decreased when a register is restored. This way, one register of the callee is exchanged for a register of the caller. If this was not been done, the condition that $\alpha$, $\beta$ and $\gamma$ may never move past each other, would be violated.

\paragraph{Page Faults on the Stack}

Unfortunatly, the current version of the MMIX architecture, described in this thesis, has a design flaw. Because if a process causes a page fault while accessing the stack (for example, when using \mi{PUSHJ}, \mi{POP}, \mi{SAVE} or setting a register), the operating system will not be able to save the state, handle the \glslink{Exception}{PE} and resume the process successfully. Because obviously, the OS needs at least a few registers to be able to handle a \glslink{Exception}{PE}. But in general (\ie if the OS does not define, that some global registers can not be used by user applications), no register is available. Thus, the OS has to save a few registers first. For example, \mi{SAVE} could be used for that purpose to save the whole state of the running program. But \mi{SAVE} will write the state onto the stack, which does of course not work, because the stack has caused the page fault. Using \mi{PUSHJ} to push some registers down would be an alternative way to supply the OS with a few registers. But equally, \mi{PUSHJ} might have to save registers on the stack. Additionally it is not possible to save the state manually, because at least one register has to be available to build the destination memory address. In sum, there is no way to save the state of the running program. The consequence is, that the OS has either to restrict the user applications to dedicate some global registers to the OS, or it has to assign a stack of constant size, that is not swapped out or similar, to the applications.

Since these restrictions are not acceptable, it has been chosen to solve this problem. The basic idea is to give the operating system a different stack than the user applications. To do so, a new special register called \sr{SS} is introduced, which holds the desired address of the \i{kernel stack}. Additionally, \mi{SAVE} and \mi{UNSAVE} are extended to offer a second version, which switches to the kernel stack and back to the user stack, respectively. That means, that \mi{SAVE} will first set \sr{S} to \sr{SS} and will save the whole state on this stack. Consequently, \mi{UNSAVE} will do the opposite, \ie it first loads all values from the kernel stack back into registers and then will switch back to the user stack. This way, a trap handler can look like:
\begin{lstlisting}[language=mmixal,caption={Trap handler, using the extended {\tt SAVE} and {\tt UNSAVE}}]
SAVE	$255,1	% the 1 requests the new version of SAVE
% ... handle the trap ...
UNSAVE	1,$255
% set $255 to rK for the current process
RESUME	1
\end{lstlisting}
Since \mi{SAVE} stores the state on a different stack (of course, the OS has to make sure that it is big enough), it does not matter for what reason the \glslink{Exception}{PE} has been triggered. Even if the user stack is currently unusable, the state can be saved and thus, the user program can be resumed afterwards.

To allow the operating system to use nested \glslink{Interrupt}{interrupts}, \ie enable \glslink{Interrupt}{interrupts} while another one is handled, a \mi{SAVE \$X,1} does not always switch the stack, but only if \sr{S} is currently in user space. Thus, \sr{SS} is expected to be in privileged space. An \mi{UNSAVE} will perform the switch only if the associated \mi{SAVE} has done it, too. Of course, the operating system should assign a different kernel stack for every process or thread. The implementation of \mi{SAVE} and \mi{UNSAVE} will be described in detail shortly.

\medskip

An alternative solution for this problem has been suggested by Prof. Dr. Martin Ruckert, a professor for mathematics at the university of applied sciences in Munich and the author of "Das MMIX-Buch" \citep{mmix-buch}. He proposed to add the rules, that
\begin{inparaenum}
	\item the page(s) affected by the range \sr{S} to \sr{O} are always mapped (\ie readable and writable) and
	\item \sr{G} is at most 224.
\end{inparaenum}
The first one ensures, that the OS can begin a trap handler with \mi{PUSHJ \$255,YZ}, because it may write to \sr{S}, but will never move \sr{S} past \sr{O}. The second makes sure, that the OS has 32 local registers available after the \mi{PUSHJ}. Because the push increases \sr{O} and might increase it to a new unmapped page. To garantee that no register is written beyond the old \sr{O} (which is mapped, because of the first rule), the second rule is necessary. If the size of the local register ring is larger than the number of local registers that can be used, the ring will always have a few slots left until a register will have to be written beyond the old \sr{O}. That is, if only 224 local registers can be used and the ring size is at least 256, at least 32 slots will be free. Of course, \mi{PUSHJ} and other functions that change \sr{O} have to trigger an \glslink{Exception}{exception} if \sr{O} should be moved to an unmapped page. The \mi{PUSHJ} that starts the trap handling will not trigger another trap, because \sr{K} is zero at that point. Additionally, the OS is forced to let no process run, for which the range \sr{S} to \sr{O} is not completely mapped.

\medskip

Both solutions have their advantages and disadvantages:
\begin{itemize}
	\item Without a separate kernel stack, a security problem arises. Because every user application can see the values, that have been written by the kernel. This might cause trouble if passwords, cryptographic keys or similar occur at that place. Therefore, every serious OS would have to establish a separate kernel stack anyway, by saving the user state and using \mi{UNSAVE} to change the stack. Thus, the first solution simplifies that and makes it more efficient by requiring only a single \mi{SAVE}.
	\item On the other hand, the first solution forces the OS to use the new \mi{SAVE} and \mi{UNSAVE} versions, if the problem should be solved and dynamic stack extension is desired. Since these instructions require a lot of memory accesses, they are time-consuming.
	\item The second solution allows the OS to use \mi{PUSHJ} and \mi{POP} to handle a trap, which is much faster.
	\item But the second solution does even require to use these instructions and forces the OS to handle a page fault caused on the stack, if necessary, before the state can be saved with \mi{SAVE}. Having only 32 registers to do so might make it difficult for large operating systems, that come with a sophisticated machinery for virtual memory. Even if it can be arranged, so that 32 registers are sufficient, it will be more inconvenient than a simple \mi{SAVE}.
	\item Additionally, the second solution restricts the operating system in two ways. All user applications have at most 224 local registers and the OS has to make sure that the pages for the range \sr{S} to \sr{O} are always mapped. This does also mean, that current programs or operating system for MMIX might not work anymore.
	\item On the contrary, the first solution is completely downwards compatible, \ie every MMIX program that respects the current specifiation will run on a new MMIX with the separate kernel stack.
\end{itemize}
It would also be imaginable to implement both solutions. This would offer more flexibility for the operating system. Some OSs might choose the simple \mi{SAVE} and \mi{UNSAVE}, while others might select \mi{PUSHJ} to be able to handle page faults more quickly and to use \mi{SAVE} only if necessary.

But for simplicity and -- most important -- compatibility, only the first solution has been implemented in GIMMIX. Because it has not yet been decided if one of the two solutions, both or something entirely different will be selected for the next version of the MMIX architecture.

\paragraph{Saving the State}

Now that the page fault problem on the stack has been explained, the extended version of \mi{SAVE} should be described. As already said, \mi{SAVE} has to store all local and global registers and all special registers that might affect the computation on the stack. Depending on whether it should switch the stack, they are stored on the current one or on the kernel stack. At first, a few preparations are necessary:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_save}, part 1 (partially pseudo-code)}]
void reg_save(int dst,bool changeStack) {
	octa oldrS = special[rS],oldrO = special[rO];
	bool doChangeStack = changeStack && !(oldrS & MSB(64));
	if(!doChangeStack)
		<check wether all stores will succeed>
	
	int oldL = L;
	O += L;
	special[rO] += L * sizeof(octa);
	
	if(doChangeStack) {
		octa newrO = special[rSS] + L * sizeof(octa) + (oldrO - oldrS);
		reg_setSpecial(rO,newrO);
		special[rS] = special[rSS];
	}
\end{lstlisting}
For later computations, the old \sr{S} and \sr{O} are saved and it is determined whether the stack should really be changed. If not, one has to make sure that all values can be stored, because this is done on the user stack, which might cause page faults. This way, the function will not change the state, if the stack is not completely mapped. Afterwards {\tt L} is saved and all local registers are pushed down. Finally, if necessary, the stack is switched. That means, \sr{O} is changed to point to the end of all local registers that have to be saved. \sr{S} is set to the beginning of the kernel stack, whereas {\tt S} is \i{not} changed here, because {\tt S} indicates the register to store, while \sr{S} indicates the memory location. That is, {\tt S} does still point to the register to save, but \sr{S} points to the kernel stack.

After the preparations, all pushed down registers (the current locals were pushed down previously), followed by \sr{L} are stored on the stack:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_save}, part 2}]
	special[rL] = L = 0;
	while(special[rO] != special[rS])
		reg_stackStore();
	reg_stackStoreVal(oldL,RSTACK_DEFAULT,S & LREG_MASK);
\end{lstlisting}

The last step stores the global and special registers on the stack:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_save}, part 3 (partially pseudo-code)}]
	if(doChangeStack) {
		reg_stackStoreVal(oldrO,RSTACK_SPECIAL,rO);
		reg_stackStoreVal(oldrO + (oldL + 1) * sizeof(octa),
			RSTACK_SPECIAL,rS);
	}
	<store global and special reg.>
	if(doChangeStack)
		S = special[rS] / sizeof(octa);
	O = S;
	special[rO] = special[rS];
	reg_set(dst,special[rO] - sizeof(octa));
}
\end{lstlisting}
If the stack is changed, the original \sr{O} and \sr{S} will have to be stored as well. As will be described shortly, \sr{S} has to be saved, so that it points to the beginning of the local registers to be restored in \mi{UNSAVE}. When all registers have been saved and the stack is changed, {\tt S} has to be corrected to correspond to the current value of \sr{S}. Finally, \sr{O} is set to \sr{S} and the top of the stack is written to the destination register. Additionally it should be mentioned, that a bit in the octa containing \sr{G} and \sr{A} will store whether the stack has been switched, which is required for \mi{UNSAVE}.

\paragraph{Restoring the State}

Of course, \mi{UNSAVE} goes in the opposite direction. It has to restore the state from a given stack pointer. The implementation starts with loading the value containing \sr{G}, \sr{A} and the "change-stack bit" and checking whether the whole procedure will succeed:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_unsave}, part 1 (partially pseudo-code)}]
void reg_unsave(octa src,bool changeStack) {
	src &= ~(octa)(sizeof(octa) - 1);	// octa-align it

	octa rGrA = mmu_readOcta(src,MEM_SIDE_EFFECTS);
	if((rGrA >> 56) < MIN_GLOBAL)
		ex_throw(EX_DYNAMIC_TRAP,TRAP_BREAKS_RULES);
	if(((rGrA) & 0xFFFFFF) & ~(octa)0x3FFFF)
		ex_throw(EX_DYNAMIC_TRAP,TRAP_BREAKS_RULES);
	if(changeStack && !(rGrA & ((octa)1 << 32)))
		changeStack = false;
	if(!changeStack)
		<check whether all loads will succeed>
\end{lstlisting}
As the listing shows, the stack is only changed back, if it is desired and the associated \mi{SAVE} had done it. Afterwards \sr{S} is set, which points to the stack to restore, and all global and special registers are loaded back into registers:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_unsave}, part 2 (partially pseudo-code)}]
	reg_setSpecial(rS,src + sizeof(octa));
	<restore global and special reg.>
	if(changeStack) {
		octa newrS = reg_stackLoadVal(RSTACK_SPECIAL,rS);
		octa newrO = reg_stackLoadVal(RSTACK_SPECIAL,rO);
		reg_setSpecial(rO,newrO);
		S = newrS / sizeof(octa);
	}

	reg_stackLoad();					// load L ...
	int k = local[S & LREG_MASK]&0xFF;	// ...into this slot
	for(int j = 0; j < k; j++)
		reg_stackLoad();
\end{lstlisting}
If the stack should be switched, \sr{S} and \sr{O} are loaded from stack as well. But \sr{S} is not set immediately -- in contrary to {\tt S} -- because the following loads should put the local registers into the corresponding slots, but they should still be loaded from the kernel stack. Finally, the new values for \sr{S}, \sr{O}, \sr{L} and \sr{G} are set:
\begin{lstlisting}[language=C,caption={Implementation of {\tt reg\_unsave}, part 3}]
	if(changeStack) {
		while(special[rS] != special[rSS])
			reg_stackLoad();
		special[rS] = S * sizeof(octa);
	}
	else {
		O = S;
		special[rO] = special[rS];
	}
	L = k > G ? G : k;
	special[rL] = L;
	special[rG] = G;
}
\end{lstlisting}
As can be seen in the listing, if the stack is changed, all values on the kernel stack, that were hidden previously, will have to be loaded back into registers. Because as soon as the program uses the user stack again, those values would be lost on the kernel stack.

\subsubsection{Trips and Traps}

The last chapter about the CPU module explains how GIMMIX implements the \glslink{Interrupt}{interrupt} and \glslink{Exception}{exception} facilities of MMIX. At first, it is described how they are triggered, followed by the explanation of the \mi{RESUME} implementation.

\paragraph{Triggering Trips and Traps}

In the end, GIMMIX uses `ex_throw` for all kinds of \glslink{Interrupt}{interrupts} and \glslink{Exception}{exceptions}. It defines the four types `EX_FORCED_TRIP`, `EX_DYNAMIC_TRIP`, `EX_FORCED_TRAP` and `EX_DYNAMIC_TRAP`, that are used as first argument to `ex_throw`. The different kinds are raised in the following ways:
\begin{itemize}
	\item Forced trips and forced traps are triggered by the instructions \mi{TRIP} and \mi{TRAP}. Thus, their execution functions call `ex_throw` directly with the corresponding arguments.
	\item Dynamic trips will call `cpu_setArithEx` to set \sr{A} correspondingly. The CPU module will call `ex_throw` later, if necessary, \ie if the enable bit for that \glslink{Exception}{AE} is set. This way, the instructions are executed completely, even if an \glslink{Exception}{AE} has been caused. MMIX defines the behaviour for all these cases.
	\item Dynamic traps for \glslink{Interrupt}{interrupts} use `cpu_setInterrupt` to set a bit in \sr{Q}. After each instruction, the CPU checks whether $\sr{Q} \land \sr{K}$ is non-zero and calls `ex_throw`, if necessary.
	\item Dynamic traps for memory faults use `cpu_setMemEx`, which sets \sr{Q}, if the bit in \sr{K} is zero. Otherwise it stores the fault location and optionally the value to store and tells the caller that an \glslink{Exception}{exception} should be raised. The reason is, that if the bit in \sr{K} is zero, failed loads should load zero and failed stores should store nothing. Thus, similarly to dynamic trips, the execution of the instruction has to be continued. The fault location and the value is required later for \sr{YY} and \sr{ZZ}.
	\item Dynamic traps for other reasons (\eg if the instruction breaks the rules) are simply raised by calling `ex_throw`.
\end{itemize}
That means, finally, all kind of trips and traps use `ex_throw`, which is catched in `cpu_execInstr`. As already mentioned, the function `cpu_triggerException` will be called in this case. Besides the first argument of `ex_throw`, which indicates the kind of trip or trap, the second argument provides additional information about the dynamic types. That is, it indicates the \glslink{Exception}{AE} for dynamic trips and the \glslink{Interrupt}{interrupt}, \glslink{Exception}{PE} or \glslink{Exception}{ME} for dynamic traps. The function `cpu_triggerException` performs the following actions:
\begin{enumerate}
	\item Determine the value for \sr{X}/\sr{XX};
	\item If it is a dynamic trap \glslink{Exception}{exception}, set the bit(s) in \sr{Q}. If $\sr{Q} \land \sr{K}$ is still zero, return;
	\item If it is a trip, set registers \sr{X}, \sr{W}, \sr{Y}, \sr{Z}, \sr{B} and \dr{255}. If a trap should be issued, \sr{K} is cleared and \sr{XX}, \sr{WW}, \sr{YY}, \sr{ZZ}, \sr{BB} and \dr{255} are set;
	\item Set the new \gls{PC}.
\end{enumerate}
The first action is the most interesting one and will thus be explained in more detail. At first, GIMMIX defines two additional, internal trap bits, that are used to determine what should be done: `TRAP_SOFT_TRANS` and `TRAP_REPEAT`. The former is used whenever an address translation should be done in software and the latter for memory faults, for which the instruction should be repeated. At first, the implementation determines the ropcode to set in \sr{X}/\sr{XX}:
\begin{lstlisting}[language=C,caption={Determining \sr{X}/\sr{XX} in {\tt cpu\_triggerException}, part 1}]
octa rxVal;
if(ex == EX_FORCED_TRAP && (bits & TRAP_SOFT_TRANS)) {
	if(bits & TRAP_PROT_EXEC)
		pc -= sizeof(tetra);
	rxVal = (octa)3 << 56;
}
else if(ex == EX_DYNAMIC_TRAP && (bits & TRAP_REPEAT)) {
	bits &= ~TRAP_REPEAT;
	rxVal = 0;
}
else
	rxVal = MSB(64);
\end{lstlisting}
If software translation is requested, it will be set to 3, which will urge \mi{RESUME} to put a translation into the corresponding TC. Additionally, if `TRAP_PROT_EXEC` is set, \ie a protection fault occurred because of a missing execution permission, the fetch will be repeated. Therefore, the \gls{PC} is decreased to set \sr{WW} to the old $@$ instead of the default $@+4$. The second condition is true for all memory faults, that require a repetition of the instruction. This is requested for all protection faults, if the $n$ field or a PTE or PTP is not equal to $n$ in \sr{V} and if the segment limit has been exceeded. That means, basically for all types of memory faults, that are theoretically resolvable by the operating system. The third ropcode in the listing is the default one, which simply skips the instruction when \mi{RESUME} is used.
 
Afterwards the instruction is put into the value to be constructed:
\begin{lstlisting}[language=C,caption={Determining \sr{X}/\sr{XX} in {\tt cpu\_triggerException}, part 2}]
if(bits & TRAP_PROT_EXEC)
	rxVal |= (octa)SWYM << 24;
else
	rxVal |= useResume ? instrRawResume : instrRaw;
\end{lstlisting}
That means, if an execution protection fault occurs, the NOP instruction \mi{SWYM} will be put into `rxVal`. As already mentioned, \mi{RESUME} will put the translation into the instruction TC in this case. Otherwise the current instruction will be put into `rxVal`. If \mi{RESUME} is executed and not \mi{RESUME} itself but the inserted instruction has caused a trap, `useResume` will be true, so that the inserted instruction will be put into `rxVal`. Finally, the \glslink{Exception}{PE} bits are added, which tells the operating system whether a \glslink{Exception}{PE} has caused the interruption and if so, which one:
\begin{lstlisting}[language=C,caption={Determining \sr{X}/\sr{XX} in {\tt cpu\_triggerException}, part 3}]
if((bits & 0xFF00000000) && ex == EX_DYNAMIC_TRAP)
	rxVal |= bits & 0xFF00000000;
\end{lstlisting}

\paragraph{Implementation of \mi{RESUME}}

As described in the chapter about the MMIX architecture, the \mi{RESUME} instruction is very complicated, because of the different ropcodes it defines to allow different kind of actions before resuming the ordinary computation. At first, the following overview describes how it is implemented in principle:
\begin{lstlisting}[language=C,caption={The implementation of \mi{RESUME} (partially pseudo-code)}]
void cpu_instr_resume(const sInstrArgs *iargs) {
	if(iargs->y > 1)
		ex_throw(EX_DYNAMIC_TRAP,TRAP_BREAKS_RULES);

	int isPriv = cpu_isPriv();
	int rx,ry,rz,rw;
	if(iargs->y == 1 && isPriv)
		rx = rXX, ry = rYY, ...
	else
		rx = rX, ry = rY, ...

	if(!isPriv) {
		if(iargs->y != 0)
			ex_throw(EX_DYNAMIC_TRAP,TRAP_PRIVILEGED_INSTR);
		if(reg_getSpecial(rw) & MSB(64))
			ex_throw(EX_DYNAMIC_TRAP,TRAP_PRIVILEGED_PC);
	}
	octa x = reg_getSpecial(rx);
	if(!(x & MSB(64)))
		<check if the ropcode can be used in desired way>

	if(iargs->y == 1 && isPriv) {
		reg_setSpecial(rK,reg_get(255));
		reg_set(255,reg_getSpecial(rBB));
	}
	cpu_setPC(reg_getSpecial(rw) - sizeof(tetra));

	if(!(x & MSB(64)))
		<execute action, depending on ropcode>
}
\end{lstlisting}
That means, the implementation is split into four parts:
\begin{enumerate}
	\item The special registers to use are determined,
	\item it is checked whether \mi{RESUME} is allowed in the way it should be executed,
	\item it resumes the ordinary computation and
	\item executes the desired action, if necessary.
\end{enumerate}
Again, \glslink{Exception}{exception}-safety has to be considered, because some of the actions may cause an \glslink{Exception}{exception}. In this case, two situations are distinguished. At first, \mi{RESUME} itself might cause an \glslink{Exception}{exception}. For example, if \mi{RESUME 1} is executed in user mode or if the "resume again" action wants to insert \mi{RESUME} itself. Second, the inserted instruction might cause \glslink{Exception}{exceptions}, such as a protection fault when accessing memory. Conceptually, this instruction is inserted into the instruction stream at position $\sr{W}|\sr{WW}-4$. Therefore, all checks regarding \mi{RESUME} itself are done before returning to the ordinary computation and the checks for the inserted instruction including its execution is performed afterwards. This order is not only important for \glslink{Exception}{exception}-safety, but also to ensure a correct environment. That is, \eg the \glslink{PC}{instruction pointer} has to be set before the actions to ensure that relative jumps and similar instructions work as expected.

The individual ropcode actions are implemented as separate functions. For example, "resume again" looks like the following:
\begin{lstlisting}[language=C,caption={Implementation of the "resume again" action}]
static void resumeAgain(bool isPriv,tetra raw) {
	sInstrArgs iargs;
	dec_decode(raw,&iargs);
	const sInstr *instr = dec_getInstr(OPCODE(raw));
	cpu_setResumeInstr(raw);
	cpu_setResumeInstrArgs(&iargs);
	if(!isPriv && (cpu_getPC() & MSB(64)))
		ex_throw(EX_DYNAMIC_TRAP,TRAP_PRIVILEGED_PC);
	instr->execute(&iargs);
}
\end{lstlisting}
As the listing shows, the instruction (`raw`) is decoded and at the end, it is executed with the corresponding execution function. The calls of `cpu_setResumeInstr` and `cpu_setResumeInstrArgs` notify the CPU module about the instruction that should be executed and about its arguments. This is necessary to allow the CPU to put, for example, the correct instruction into \sr{X}|\sr{XX}, if an \glslink{Exception}{exception} is triggered (see `useResume` above). Furthermore, it has to be checked whether the CPU was in user mode previously (`!isPriv`) and has changed into the privileged mode. This is of course not allowed, but without this check it would be possible to set \sr{W} to 0 and perform a \mi{RESUME 0} in user mode to execute one instruction in privileged mode. Because this instruction is executed at $\sr{W}-4$ and the instruction pointer determines the mode the CPU runs in.

