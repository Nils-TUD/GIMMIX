\chapter{Test System}

As already mentioned in the introduction, it is very important that GIMMIX behaves correctly according to the MMIX specification. Additionally, since not all details are defined by the specification and to increase the confidence that everything has been understood and implemented correctly, the behaviour of GIMMIX is compared to the one of MMIX-SIM and MMIX-PIPE.

For this reason, a sophisticated test system has been built, that consists of two parts. At first, test programs for MMIX are executed on as many of the three simulators as possible and their results are compared. Second, \glslink{Unit testing}{unit tests} are used to test parts of GIMMIX, that are not visible to the software. This chapter describes the ideas behind both systems and the most important facilities that are required.

\section{Program Tests}

The basic idea behind the program tests is to let the simulators execute some instructions, that put values into registers and/or write to specific memory locations, and check afterwards if the registers and memory locations have the expected content.

\subsection{Test Infrastructure}

Each test consists of a \i{mms-file}, that holds the assembly code to test, and a \i{test-file}, that specifies the expected results. The first line of the test-file describes the values to compare, while the rest of the file is matched against the produced values. The first line is passed to the \i{post commands} module, which interprets it and prints the desired values. The line consists of an arbitrary number of commands, separated by ",". Each command can either be {\tt r:\dr{X}..\dr{Y}} to print dynamic registers \dr{X}, \dr{(X + 1)}, \dots, \dr{Y} or {\tt m:X..Y} to print the octas between physical memory addresses {\tt X} and {\tt Y}, inclusively.

MMIX-SIM, MMIX-PIPE and GIMMIX have been extended to support these post commands. They can be specified via command line argument to urge the simulator to execute them after the execution of the program is finished. This way, the contents of the specified registers or memory locations are printed to {\tt stdout}. GIMMIX provides the shellscript \file{runtests.sh}, that executes all test programs on the simulators, whereas the post commands are extracted from the first line of the test-file. Afterwards, the output of GIMMIX is compared to the expected output (all lines of the test-file, except the first one), to the output of MMIX-PIPE and to the output of MMIX-SIM. If there are any differences, the tool diff\footnote{Diff is a comparison utility, that finds and displays differences between two files. \citep{gldiff}} will be used to illustrate them. Additionally, it distinguishes between the following subfolders of folder \file{tests}, in which all program tests reside:
\begin{itemize}
	\item \file{user}: This directory contains tests, that can and should be executed in user mode. All three simulators have an option to execute a program in user mode, for which an initial environment is supplied. That is, \glslink{Paging}{paging} is pre-configured by setting \sr{V} and PTEs all installed for all four segments. Furthermore, \sr{S}, \sr{O}, \sr{K}, \sr{T} and \sr{TT} are initialized correspondingly. Most important, all tests in this folder are executable with all three simulators, \ie also with MMIX-SIM.
	\item \file{kernel}: This directory holds the tests, that should be executed in privileged mode. Therefore, they do not expect this initial environment, but start without any pre-configuration and in privileged mode. These tests are executed with MMIX-PIPE and GIMMIX only.
	\item \file{diff}: To test some behaviours that are implementation-defined, to test the fix for the page fault problem on the stack or to test cases that are currently erroneous in MMIX-PIPE or MMIX-SIM, the folder \file{diff} is used. All tests in it are executed on GIMMIX only.
	\item \file{cli}: Finally, this directory holds tests for the command line interface. Thus, the tests are typically no programs for MMIX, but scripts for the CLI. Of course, they are executed in GIMMIX only.
\end{itemize}
All other folders are ignored by \file{runtests.sh}. But it is noteworthy, that the folder \file{manual} holds some programs for GIMMIX, that make use of the yet existing devices. These are not included into the program test system, because they are not automatically testable that easily.

\subsection{Test Programs}

Although the tests programs can not be explained in detail, this section will give an overview about them.

\subsubsection{User Tests}

Since all three simulators can execute the user tests, as many cases as possible are tested in this way. Most of them simply test the behaviour of a set of instructions. While a part of the tests have been written manually, all tests, in which the individual test cases work in a common pattern, are generated by scripts or programs. All these generators are placed in the directory \file{testgen}, which contains two groups of generators. The first group are \gls{Ruby} scripts, that are used for most of the tests. \gls{Ruby} has been chosen, because it allows a quick development of the tests and provides an arbitrary-precision arithmetic, independend of the underlying platform (in other scripting languages, such as \gls{PHP}, the width of integers depends on the platform, on which the interpreter runs \citep{php-intwidth}). This way, \eg bit operations with 64-bit integers can be performed, regardless of whether the generator is run on a 32-bit or 64-bit platform. The second group are C programs, that are primarily used for the floating point arithmetic tests. Because this way, the double precision arithmetic of a well tested language and platform can be utilized to make sure, that the implementation of the floating point instructions in GIMMIX is correct. \gls{Ruby} is not well suited in this case, because of the arbitrary precision arithmetic; instead C fits better, because of the amount of control and the similarities of double precision arithmetic and 64-bit float arithmetic in MMIX. Additionally it is noteworthy, that some of these test generators expect x86 as underlying platform, because the rounding mode of the x87 floating point unit is set and some reactions on not defined details by IEEE-754 and therefore x87-specific behaviour are necessary. For example, the sign-bit of \NaN results is not defined by the standard \citep[pg. 17]{ieee754}.

\subsubsection{Kernel Tests}

Most of the tests in the \file{kernel} directory have been written manually. They test the PEs of MMIX, \glslink{Interrupt}{interrupts}, \glslink{Paging}{paging} and privileged instructions. But some of them are generated automatically as well. Most important, the \glslink{Paging}{paging} tests are generated automatically with a \gls{Ruby} script, that generates PTPs, PTEs and access tests for a given value of \sr{V}.

\subsubsection{Diff Tests}

As already mentioned, MMIX-PIPE and GIMMIX differ in a few details. For example, the values of \sr{XX}, \sr{YY} and \sr{ZZ} are not equal for some \glslink{Exception}{PEs}, because MMIX does not define it completely. Another example is, that GIMMIX will trigger an \glslink{Exception}{exception} if a not existing memory location in the I/O space is accessed or a bit in \sr{Q} is set, that is not used for an \glslink{Interrupt}{interrupt}, \glslink{Exception}{PE} or \glslink{Exception}{ME}, while MMIX-PIPE will not do that. The second reason for this directory is, that the fix for the page fault problem on the stack has to be tested, which of course does not work in MMIX-PIPE.

\subsubsection{CLI Tests}

Finally, the directory \file{cli} contains scripts to test the language and commands of the CLI. In this case, obviously, the expected results are only compared with the actual results. Currently, the expressions of the language, handling of whitespace and the most critical and important commands such as \gcmd{p}, \gcmd{set}, \gcmd{e}, \gcmd{b}, \gcmd{d}, \gcmd{tr} and a few others are tested.

\subsection{Code Coverage}

To ensure that all lines in the important parts of the simulator are executed by the tests, a small code coverage system has been developed. The basic functional principle is to cause \gls{gcc} to let the simulator generate information for gcov\footnote{Gcov is a test coverage program, that can be used together with \gls{gcc} to improve the performance of a program and discover untested parts of it. \citep{gcov}} during the execution of the simulator. The shellscript \file{runcov.sh} runs the simulator for a specific or for all tests and uses gcov to produce the coverage information. This information is analyzed by a few \gls{Ruby} scripts to generate HTML pages, that display the results. These pages contain a list of all tests, whereas each of them displays the source files of the simulator with the percentage of executed lines. Additionally, one HTML page per source file is generated, displaying the source code and highlighting the lines correspondingly, depending on whether they have been executed or not.

\section{Unit Tests}

The second part of the test system consists of \glslink{Unit testing}{unit tests}. As already said, they are used to test the parts of GIMMIX, that are not visible to the software or would be difficult to test. To achieve that, a small \glslink{Unit testing}{unit test} framework has been developed. Although existing frameworks like CUnit\footnote{Available at \url{http://cunit.sourceforge.net}.} or Check\footnote{Available at \url{http://check.sourceforge.net}.} have been considered, it has been decided to built an own framework, because the existing ones are quite heavy and most of their functionality would not be used anyway. Additionally, of course they do not provide special functions to compare bytes, wydes, tetras and octas. Thus, by building our own framework, it can be designed to fit our needs exactly.

The test framework found in \file{unittests/test.c} allows it to register and run tests, and offers functions to assert equalities. The function `test_register` is intended to register a \i{test suite}, which contains one or more \i{test cases}. Each test case has a name and a function, that runs that test case. After registering all test suites, `test_start` can be called to execute all test cases in all test suites. To support a convenient and informative facility for asserts, it offers the macros `test_assertTrue`, `test_assertInt`, `test_assertByte`, `test_assertOcta` and so on, which call the actual assert function with the current function name and line number. This way, reasons of failures can be identified and fixed more quickly.

Currently, tests suites exist for testing the physical memory (independent of the rest of the memory hierarchy), the complete memory hierarchy (focused on the different flags such as `MEM_UNCACHED` or `MEM_SIDE_EFFECTS`), the system instructions like \mi{LDUNC}, \mi{SYNCD}, \mi{SYNC} and so on and the interruptibility of instructions.

